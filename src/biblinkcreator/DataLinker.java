/*
 * Copyright (C) 2017 David Nazarian
 *
 * This file is part of BibLinkCreator.
 *
 * BibLinkCreator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BibLinkCreator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BibLinkCreator.  If not, see <http://www.gnu.org/licenses/>.
 */
package biblinkcreator;

import biblinkcreator.Logger.*;
import biblinkcreator.Identifier.*;
import biblinkcreator.DataStructure.*;
import java.io.*;
import java.net.URL;
import java.nio.file.*;
import java.util.*;
import org.json.JSONObject;
import org.apache.commons.io.FileUtils;
import org.openrdf.model.*;
import org.openrdf.query.*;
import org.openrdf.repository.*;
import org.openrdf.repository.http.HTTPRepository;

/**
 * A mechanism that links bibliographic data retrieved from semantic
 * repositories. <br><br>
 * Author: David Nazarian
 * @author David Nazarian
 */
public class DataLinker {
    // Number of created links needed for a message to be logged during the
    // link creation.
    private int linkMessageRecords = 5000;
    // Download parameters for the doi.org URL resolver API.
    private DownloadParameterData doiResolverDLParameterData = 
            new DownloadParameterData(2000, 2000, 20);
    // The number of consecutive errors occured during doi.org URL resolving.
    private int consecutiveErrors = 0;
    // The number of created links to be batch inserted.
    private int insertBatchSize = 5000;
    // Repository connection to the destination repository where the created
    // links will be saved. It is also the source of the data that will be used
    // for the link creation.
    private RepositoryConnection destRepositoryConn = null;
    // Provides structure for the saved data.
    private Schema schema = null;
    // Path for the downloaded json files of the doi URL resolver API.
    private Path downloadPath;
    // Logs messages generated by the methods of the class.
    private Logger logger = null;
    
    /**
     * @param destRepositoryInfo Information about the destination repository
     * where the created links will be saved and source data will be retrieved
     * from.
     * @param logger A logger that will log generated messages.
     */
    public DataLinker(RepositoryInfo destRepositoryInfo, Logger logger) {
        if (logger != null)
            this.logger = logger;
        else
            this.logger = new Logger(PrintType.None, "", false);
        // Logs the missing necessary repository parameters for the destination.
        if (destRepositoryParameterMissing(destRepositoryInfo))
            return;
        
        HTTPRepository destHTTPRepository;
        String destServerURLString = destRepositoryInfo.getServerURLString();
        // The ID of the destination repository set during its creation.
        String destRepositoryID = destRepositoryInfo.getRepositoryID();
        Quadstore quadstore = new Quadstore();
        // Provides structure for the saved data.
        schema = new Schema(destRepositoryInfo.getSchemaURLString());
        // Checks for valid credentials for the destination repository server.
        if (quadstore.isConnectionAuthorized(destServerURLString,
                destRepositoryInfo.getAuthenticationData(), logger) == false)
            return;
        
        try {
            destHTTPRepository =
                    new HTTPRepository(destServerURLString, destRepositoryID);
            quadstore.setAuthentication(
                    destRepositoryInfo.getAuthenticationData(),
                    destHTTPRepository);
            destRepositoryConn = destHTTPRepository.getConnection();
        }
        catch (Exception ex) {
            this.logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
    }
    
    /**
     * @return The number of created links needed for a message to be logged
     * during the link creation.
     */
    public int getLinkMessageRecords() {
        return linkMessageRecords;
    }
    
    /**
     * @param linkMessageRecords The number of created links needed for a
     * message to be logged during the link creation.
     */
    public void setLinkMessageRecords(int linkMessageRecords) {
        this.linkMessageRecords = linkMessageRecords;
    }
    
    /**
     * @return The download parameters for the doi.org URL resolver API.
     */
    public DownloadParameterData getDOIResolverDLParameterData() {
        return doiResolverDLParameterData;
    }
    
    /**
     * @param doiResolverDLParameterData The download parameters for the doi.org
     * URL resolver API.
     */
    public void setDOIResolverDLParameterData(
            DownloadParameterData doiResolverDLParameterData) {
        this.doiResolverDLParameterData = doiResolverDLParameterData;
    }
    
    /**
     * @return The number of created links to be batch inserted.
     */
    public int getInsertBatchSize() {
        return insertBatchSize;
    }
    
    /**
     * @param insertBatchSize The number of created links to be batch inserted.
     */
    public void setInsertBatchSize(int insertBatchSize) {
        this.insertBatchSize = insertBatchSize;
    }
    
    /**
     * Closes the connection to the destination repository where the created
     * links will be saved and source data will be retrieved from. 
     */
    public void close() {
        try {
            destRepositoryConn.close();        
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
    }
    
    /**
     * Links data retrieved from two sources (named graphs) based on a
     * category-A identifier (as defined in the Identifier class), a title and a
     * year (if exists).
     * @param linkSourceARepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * source data.
     * @param linkSourceBRepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * destination data.
     * @param linkTypeURIString The URI string of the predicate which will be
     * used to link a subject URI to an object URI.
     * @param resolveDOI Determines if doi.org URL resolving will take place.
     * @param categoryAIdentifierType The type of category-A identifier to be
     * used for the data retrieval from the two named graphs.
     * @param categoryAToleranceData Data comparison tolerance parameters.
     * @param similaritySelector The parameterized string similarity measure to
     * be used.
     * @return The number of links created and saved.
     */
    public int linkData(String linkSourceARepositoryName,
            String linkSourceBRepositoryName, String linkTypeURIString,
            boolean resolveDOI, CategoryAIdentifierType categoryAIdentifierType,
            CategoryAToleranceData categoryAToleranceData,
            StringSimilaritySelector similaritySelector) {
        int linkCount;
        // The tolerance data to be used during the comparisons.
        ToleranceData toleranceData = new ToleranceData(
                0, categoryAToleranceData.getTitleThresholdA(),
                categoryAToleranceData.getTitleThresholdB(),
                categoryAToleranceData.getYearMaxDifference());
        Identifier identifier = new Identifier();
        // The type of the identifier used for the link creation.
        IdentifierType identifierType =
                identifier.getIdentifierType(categoryAIdentifierType);
        // Creates the links and saved them into a separate named graph.
        linkCount = linkData(linkSourceARepositoryName,
                linkSourceBRepositoryName, linkTypeURIString, resolveDOI,
                identifierType, toleranceData, similaritySelector);
        
        return linkCount;
    }
    
    /**
     * Links data retrieved from two sources (named graphs) based on a
     * category-B identifier (as defined in the Identifier class), a title and a
     * year.
     * @param linkSourceARepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * source data.
     * @param linkSourceBRepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * destination data.
     * @param linkTypeURIString The URI string of the predicate which will be
     * used to link a subject URI to an object URI.
     * @param resolveDOI Determines if doi.org URL resolving will take place.
     * @param categoryBIdentifierType The type of category-B identifier to be
     * used for the data retrieval from the two named graphs.
     * @param categoryBToleranceData Data comparison tolerance parameters.
     * @param similaritySelector The parameterized string similarity measure to
     * be used.
     * @return The number of links created and saved.
     */
    public int linkData(String linkSourceARepositoryName,
            String linkSourceBRepositoryName, String linkTypeURIString,
            boolean resolveDOI, CategoryBIdentifierType categoryBIdentifierType,
            CategoryBToleranceData categoryBToleranceData,
            StringSimilaritySelector similaritySelector) {
        int linkCount;
        // The tolerance data to be used during the comparisons.
        ToleranceData toleranceData = new ToleranceData(
                categoryBToleranceData.getTitleThreshold(), 0, 0, 0);
        Identifier identifier = new Identifier();
        // The type of the identifier used for the link creation.
        IdentifierType identifierType =
                identifier.getIdentifierType(categoryBIdentifierType);
        // Creates the links and saved them into a separate named graph.
        linkCount = linkData(linkSourceARepositoryName,
                linkSourceBRepositoryName, linkTypeURIString, resolveDOI, 
                identifierType, toleranceData, similaritySelector);
        
        return linkCount;
    }
    
    /**
     * Links data retrieved from two sources (named graphs).
     * @param linkSourceARepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * source data.
     * @param linkSourceBRepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * destination data.
     * @param linkTypeURIString The URI string of the predicate which will be
     * used to link a subject URI to an object URI.
     * @param resolveDOI Determines if doi.org URL resolving will take place.
     * @param identifierType The type of the identifier to be used for the data
     * retrieval from the two named graphs.
     * @param toleranceData Data comparison tolerance parameters.
     * @param similaritySelector The parameterized string similarity measure to
     * be used.
     * @return The number of links created and saved.
     */
    private int linkData(String linkSourceARepositoryName,
            String linkSourceBRepositoryName, String linkTypeURIString,
            boolean resolveDOI, IdentifierType identifierType,
            ToleranceData toleranceData,
            StringSimilaritySelector similaritySelector) {
        int linkCount = 0;
        
        if (resolveDOI) {
            try {
                // Creates a temporary download folder.
                downloadPath = Files.createTempDirectory("biblc_doiresolve_");
            }
            catch (Exception ex){
                logger.logMessage("Could not create temp directory," +
                        "resolveDOI will be set to false",
                        MessageCategory.Warning);
                resolveDOI = false;
            }
        }
        
        Identifier identifier = new Identifier();
        // An identifier name for logging.
        String identifierName = identifier.getIdentifierName(identifierType);
        logger.logMessage("Searching for " + identifierName +
                " links between " + linkSourceARepositoryName + " and " +
                linkSourceBRepositoryName + "...", MessageCategory.Info);
        
        switch (identifierType) {
            // Category-A identifiers.
            case arXivID: case DOI: case ISBN: case LCCN: case OCLC: case PMID:
                // Creates links between the provided source and destination
                // named graphs and saved them.
                linkCount = insertCategoryALinks(linkSourceARepositoryName,
                        linkSourceBRepositoryName, linkTypeURIString,
                        resolveDOI, identifierType, toleranceData,
                        similaritySelector);
                break;
            // Category-B identifiers.
            case ISSN: case JournalTitle:
                // Creates links between the provided source and destination
                // named graphs and saved them.
                linkCount = insertCategoryBLinks(linkSourceARepositoryName,
                        linkSourceBRepositoryName, linkTypeURIString,
                        resolveDOI, identifierType, toleranceData,
                        similaritySelector);                
                break;
        }
        
        logger.logMessage("\ttotal " + identifierName + " links found : " +
                String.valueOf(linkCount), MessageCategory.Info);
        
        if (resolveDOI) {
            FileOperation fileOperation = new FileOperation();
            // Deletes the temporary download folder.
            fileOperation.deleteTempFolder(downloadPath);
        }
        
        return linkCount;
    }
    
    /**
     * Exports the created links into a specified file in N-Triples format based
     * on the names of the link source and destination repository and the type
     * of the identifier involved in the link creation.
     * @param linkSourceARepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * source data.
     * @param linkSourceBRepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * destination data.
     * @param identifierType The type of the identifier used to create the
     * links.
     * @param exportPathName The path (including the filename) where the
     * exported links will be saved.
     */
    public void exportLinks(String linkSourceARepositoryName,
            String linkSourceBRepositoryName, IdentifierType identifierType,
            String exportPathName) {
        // The named graph URI string which will be used in the SPARQL query 
        // filter to retrieve the links.
        String graphURIString = schema.getLinksGraphURIString(
                linkSourceARepositoryName, linkSourceBRepositoryName,
                identifierType);
        // Gets the SPARQL query which will be used to export the links.
        String exportQuery =
                getExportQuery(schema.getPropertyPath(), graphURIString);
        // Exports the links in the specified file.
        saveLinks(exportQuery, exportPathName);
    }
    
    /**
     * Exports the created links into a specified file in N-Triples format based
     * on the names of the link source and destination repository.
     * @param linkSourceARepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * source data.
     * @param linkSourceBRepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * destination data.
     * @param exportPathName The path (including the filename) where the
     * exported links will be saved.
     */
    public void exportLinks(String linkSourceARepositoryName,
            String linkSourceBRepositoryName, String exportPathName) {
        // The named graph URI string which will be used in the SPARQL query 
        // filter to retrieve the links.
        String graphURIString = schema.getLinksGraphURIString(
                linkSourceARepositoryName, linkSourceBRepositoryName);
        // Gets the SPARQL query which will be used to export the links.
        String exportQuery =
                getExportQuery(schema.getPropertyPath(), graphURIString);
        // Exports the links in the specified file.
        saveLinks(exportQuery, exportPathName);
    }
    
    /**
     * Exports the created links into a specified file in N-Triples format based
     * on the name of the link source repository.
     * @param linkSourceARepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * source data.
     * @param exportPathName The path (including the filename) where the
     * exported links will be saved.
     */
    public void exportLinks(String linkSourceARepositoryName,
            String exportPathName) {
        // The named graph URI string which will be used in the SPARQL query 
        // filter to retrieve the links.
        String graphURIString = schema.getLinksGraphURIString(
                linkSourceARepositoryName);
        // Gets the SPARQL query which will be used to export the links.
        String exportQuery =
                getExportQuery(schema.getPropertyPath(), graphURIString);
        // Exports the links in the specified file.
        saveLinks(exportQuery, exportPathName);
    }
    
    /**
     * Gets a SPARQL query string which can be used to retrieve created links.
     * @param propertyPath The path used for the prefix prop.
     * @param graphURIString The named graph URI string which will be used in
     * the SPARQL query filter.
     * @return A SPARQL query.
     */
    private String getExportQuery(String propertyPath, String graphURIString) {
        String exportQuery = 
            "PREFIX prop: <" + propertyPath + ">                  \n" +
            "                                                     \n" +
            "SELECT                                               \n" +
            "    *                                                \n" +
            "WHERE                                                \n" +
            "    {                                                \n" +
            "        GRAPH ?graph {?subject ?predicate ?object .} \n" +
            "        FILTER (strstarts(str(?graph), \"" +
                     graphURIString +  "\"))                      \n" +
            "    }                                                \n";
        
        return exportQuery;
    }
    
    /**
     * Links data based on category-A identifiers, titles and years (if exist).
     * @param linkSourceARepositoryName The repository name (alias) which will
     * be used to form the named graph URI for the link source.
     * @param linkSourceBRepositoryName The repository name (alias) which will
     * be used to form the named graph URI for the link destination.
     * @param linkTypeURIString The URI string of the predicate which will be
     * used to link a subject URI to an object URI.
     * @param resolveDOI Determines if doi.org URL resolving will take place.
     * @param identifierType The type of the identifier to be used for the data
     * retrieval from the link source and destination named graphs.
     * @param toleranceData Data comparison tolerance parameters.
     * @param similaritySelector The parameterized string similarity measure to
     * be used.
     * @return The number of the created links.
     */
    private int insertCategoryALinks(String linkSourceARepositoryName,
            String linkSourceBRepositoryName, String linkTypeURIString,
            boolean resolveDOI, IdentifierType identifierType,
            ToleranceData toleranceData,
            StringSimilaritySelector similaritySelector) {
        int linkCount = 0;
        TupleQueryResult queryResult = null;
        
        try {
            // Gets the SPARQL query which will be used for the data retrieval.
            String dataSelectionQuery = getDataSelectionQuery(
                    linkSourceARepositoryName, linkSourceBRepositoryName,
                    identifierType);
            // Retrieves data from the destination repository.
            queryResult = destRepositoryConn.prepareTupleQuery(
                    QueryLanguage.SPARQL, dataSelectionQuery).evaluate();
            StringSimilarity stringSimilarity = new StringSimilarity();
            String subjectStringA, titleStringA, yearStringA,
                    subjectStringB, titleStringB, yearStringB;
            URI subjectURI, predicateURI, objectURI;
            int yearA, yearB, yearDifference;
            int logCount = 0;
            double titleCoefficient;
            boolean linkFound;
            BindingSet bindingSet;
            ValueFactory valueFactory = destRepositoryConn.getValueFactory();
            // Creation of the predicate URI for the created links.
            predicateURI = valueFactory.createURI(linkTypeURIString);
            Set<LinkData> linkDataSet = new HashSet<>();
            Set<LinkData> collectiveSet = new HashSet<>();
            Identifier identifier = new Identifier();
            // An identifier name for logging.
            String identifierName =
                    identifier.getIdentifierName(identifierType);
            int maxAllowedConsecutiveErrors =
                    doiResolverDLParameterData.getMaxAllowedConsecutiveErrors();
            
            while (queryResult.hasNext()) {
                linkFound = false;
                bindingSet = queryResult.next();
                // Reads the subject string which will be used as the subject
                // of the created link.
                subjectStringA = bindingSet.getBinding(
                        "subjectA").getValue().stringValue();
                // Reads the subject string which will be used as the object
                // of the created link.
                subjectStringB = bindingSet.getBinding(
                        "subjectB").getValue().stringValue();
                // If the current subject or object URI can't be used for the
                // link creation, then they are omitted from it.
                if (resolveDOI == false &&
                        subjectURIsMustBeRejected(subjectStringA,
                        subjectStringB, resolveDOI))
                    continue;
                
                if (consecutiveErrorsExceedMaxAllowed(consecutiveErrors,
                        maxAllowedConsecutiveErrors))
                    return linkCount;
                // Reads the title from source-A.
                titleStringA = bindingSet.getBinding(
                        "titleA").getValue().stringValue();
                // Since the publication year variable is optional it must be
                // checked first for existance.
                if (bindingSet.getBinding("yearA") != null)
                    // Reads the publication year string from source-A.
                    yearStringA = bindingSet.getBinding(
                            "yearA").getValue().stringValue();
                else
                    yearStringA = "";
                // Reads the title from source-B.
                titleStringB = bindingSet.getBinding(
                        "titleB").getValue().stringValue();
                // Since the publication year variable is optional it must be
                // checked first for existence.
                if (bindingSet.getBinding("yearB") != null)
                    // Reads the publication year string from source-B.
                    yearStringB = bindingSet.getBinding(
                            "yearB").getValue().stringValue();
                else
                    yearStringB = "";
                // If a publication year has been retrieved from both sources,
                // then they are involved in the comparisons.
                if (yearStringA.length() > 0 && yearStringB.length() > 0) {
                    // Integer representation of the yearA string.
                    yearA = Integer.parseInt(yearStringA);
                    // Integer representation of the yearB string.
                    yearB = Integer.parseInt(yearStringB);
                    // Difference of the years of the two souces.
                    yearDifference = Math.abs(yearA - yearB);
                    // If the year difference is in the allowed range, then
                    // the titles will be compared.
                    if (yearDifference <=
                            toleranceData.getYearMaxDifference()) {
                        // Gets the string similarity coefficient for the
                        // titles based on the selected string similarity
                        // measure and its parameters.
                        titleCoefficient = stringSimilarity.getCoefficient(
                                titleStringA, titleStringB, similaritySelector);
                        // If the string similarity coefficient of the titles 
                        // is above the specified threshold, then a link has
                        // been found.
                        if (titleCoefficient >=
                                toleranceData.getTitleThresholdA())
                            linkFound = true;
                    }
                }
                // A publication year hasn't been retrieved from either of the
                // sources.
                else {
                    // Gets the string similarity coefficient for the titles
                    // based on the selected string similarity measure and its
                    // parameters.
                    titleCoefficient = stringSimilarity.getCoefficient(
                            titleStringA, titleStringB, similaritySelector);
                    // If the string similarity coefficient of the titles is
                    // above the specified threshold, then a link has been
                    // found.
                    if (titleCoefficient >= toleranceData.getTitleThresholdB())
                        linkFound = true;
                }
                
                if (linkFound) {
                    // If the current subject or object URI can't be used for
                    // the link creation, then they are omitted from it.
                    if (resolveDOI && subjectURIsMustBeRejected(
                            subjectStringA, subjectStringB, resolveDOI))
                        continue;
                    // Creation of the subject URI of the link.
                    subjectURI = valueFactory.createURI(subjectStringA);
                    // Creation of the object URI of the link.
                    objectURI = valueFactory.createURI(subjectStringB);
                    // The subject and object are added into a list.
                    linkDataSet.add(new LinkData(subjectURI, objectURI));
                    // The subject and object are added into a collective list.
                    collectiveSet.add(new LinkData(subjectURI, objectURI));
                    linkCount = collectiveSet.size();
                    // The collected links will be sent to the repository as a
                    // batch.
                    if (linkDataSet.size() >= insertBatchSize) {
                        executeTransaction(linkDataSet,
                                linkSourceARepositoryName,
                                linkSourceBRepositoryName, predicateURI,
                                destRepositoryConn, identifierType);
                        linkDataSet.clear();
                    }
                    
                    logCount = logLinkMessage(logCount, linkCount,
                            identifierName);
                }
            }
            // The remaining links will be sent to the repository.
            if (linkDataSet.size() > 0) {
                executeTransaction(linkDataSet, linkSourceARepositoryName,
                        linkSourceBRepositoryName, predicateURI,
                        destRepositoryConn, identifierType);
                linkDataSet.clear();
            }
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
        finally {
            if (queryResult != null) {
                try {
                    queryResult.close();
                }
                catch (Exception ex) {
                }
            }
        }
        
        return linkCount;
    }
    
    /**
     * Links data based on category-B identifiers, titles and years.
     * @param linkSourceARepositoryName The repository name (alias) which will
     * be used to form the named graph URI for the link source.
     * @param linkSourceBRepositoryName The repository name (alias) which will
     * be used to form the named graph URI for the link destination.
     * @param linkTypeURIString The URI string of the predicate which will be
     * used to link a subject URI to an object URI.
     * @param resolveDOI Determines if doi.org URL resolving will take place.
     * @param identifierType The type of the identifier to be used for the data
     * retrieval from the link source and destination named graphs.
     * @param toleranceData Data comparison tolerance parameters.
     * @param similaritySelector The parameterized string similarity measure to
     * be used.
     * @return The number of the created links.
     */
    private int insertCategoryBLinks(String linkSourceARepositoryName,
            String linkSourceBRepositoryName, String linkTypeURIString,
            boolean resolveDOI, IdentifierType identifierType,
            ToleranceData toleranceData,
            StringSimilaritySelector similaritySelector) {
        int linkCount = 0;
        TupleQueryResult queryResult = null;
        
        try {
            // Gets the SPARQL query which will be used for the data retrieval.
            String dataSelectionQuery = getDataSelectionQuery(
                    linkSourceARepositoryName, linkSourceBRepositoryName,
                    identifierType);
            // Retrieves data from the destination repository.
            queryResult = destRepositoryConn.prepareTupleQuery(
                    QueryLanguage.SPARQL, dataSelectionQuery).evaluate();
            StringSimilarity stringSimilarity = new StringSimilarity();
            String subjectStringA, titleStringA, subjectStringB, titleStringB;
            URI subjectURI, predicateURI, objectURI;
            int logCount = 0;
            double titleCoefficient;
            BindingSet bindingSet;
            ValueFactory valueFactory = destRepositoryConn.getValueFactory();
            // Creation of the predicate URI for the created links.
            predicateURI = valueFactory.createURI(linkTypeURIString);
            Set<LinkData> linkDataSet = new HashSet<>();
            Set<LinkData> collectiveSet = new HashSet<>();
            Identifier identifier = new Identifier();
            String identifierName =
                    identifier.getIdentifierName(identifierType);
            int maxAllowedConsecutiveErrors =
                    doiResolverDLParameterData.getMaxAllowedConsecutiveErrors();
            
            while (queryResult.hasNext()) {
                bindingSet = queryResult.next();
                // Reads the subject string which will be used as the subject
                // of the created link.
                subjectStringA = bindingSet.getBinding(
                        "subjectA").getValue().stringValue();
                // Reads the subject string which will be used as the object
                // of the created link.
                subjectStringB = bindingSet.getBinding(
                        "subjectB").getValue().stringValue();
                // If the current subject or object URI can't be used for the
                // link creation, then they are omitted from it.
                if (resolveDOI == false &&
                        subjectURIsMustBeRejected(subjectStringA,
                                subjectStringB, resolveDOI))
                    continue;
                
                if (consecutiveErrorsExceedMaxAllowed(consecutiveErrors,
                        maxAllowedConsecutiveErrors))
                    return linkCount;
                // Reads the title from source-A.
                titleStringA = bindingSet.getBinding(
                        "titleA").getValue().stringValue();
                // Reads the title from source-B.
                titleStringB = bindingSet.getBinding(
                        "titleB").getValue().stringValue();
                // Gets the string similarity coefficient for the titles based
                // on the selected string similarity measure and its parameters.
                titleCoefficient = stringSimilarity.getCoefficient(
                        titleStringA, titleStringB, similaritySelector);
                // If the string similarity coefficient of the titles is above
                // the specified threshold, then a link has been found.                
                if (titleCoefficient >= toleranceData.getTitleThreshold()) {
                    // If the current subject or object URI can't be used for
                    // the link creation, then they are omitted from it.
                    if (resolveDOI && subjectURIsMustBeRejected(subjectStringA,
                            subjectStringB, resolveDOI))
                        continue;
                    // Creation of the subject URI of the link.
                    subjectURI = valueFactory.createURI(subjectStringA);
                    // Creation of the object URI of the link.
                    objectURI = valueFactory.createURI(subjectStringB);
                    // The subject and object are added into a list.
                    linkDataSet.add(new LinkData(subjectURI, objectURI));
                    // The subject and object are added into a collective list.
                    collectiveSet.add(new LinkData(subjectURI, objectURI));
                    linkCount = collectiveSet.size();
                    // The collected links will be sent to the repository as a
                    // batch.
                    if (linkDataSet.size() >= insertBatchSize) {
                        executeTransaction(linkDataSet,
                                linkSourceARepositoryName,
                                linkSourceBRepositoryName, predicateURI,
                                destRepositoryConn, identifierType);
                        linkDataSet.clear();
                    }
                    
                    logCount = logLinkMessage(logCount, linkCount,
                            identifierName);
                }
            }
            // The remaining links will be sent to the repository.
            if (linkDataSet.size() > 0) {
                executeTransaction(linkDataSet, linkSourceARepositoryName,
                        linkSourceBRepositoryName, predicateURI,
                        destRepositoryConn, identifierType);
                linkDataSet.clear();
            }
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
        finally {
            if (queryResult != null) {
                try {
                    queryResult.close();
                }
                catch (Exception ex) {
                }
            }
        }
        
        return linkCount;
    }
    
    /**
     * Sends the created links batch into the destination repository.
     * @param batchInsertSet A set containing the created links batch.
     * @param repositoryAName The name (alias) of the source-A repository
     * providing the subjects of the links.
     * @param repositoryBName The name (alias) of the source-B repository
     * providing the objects of the links.
     * @param predicateURI The URI of the predicate to be used for the linking.
     * @param destRepositoryConn A connection to the destination repository
     * where the created links will be sent.
     * @param identifierType The type of the identifier used for the link
     * creation.
     */
    private void executeTransaction(Set<LinkData> batchInsertSet,
            String repositoryAName, String repositoryBName, URI predicateURI,
            RepositoryConnection destRepositoryConn,
            IdentifierType identifierType) throws RepositoryException {        
        try {
            // The named graph URI string which will be used to create the URI 
            // of the graph where the links will be saved.
            String graphURIString = schema.getLinksGraphURIString(
                    repositoryAName, repositoryBName, identifierType);
            URI graphURI, subjectURI, objectURI;
            ValueFactory valueFactory = destRepositoryConn.getValueFactory();
            // Creates the URI of the named graph where the links will be saved.
            graphURI = valueFactory.createURI(graphURIString);
            Iterator insertSetIterator = batchInsertSet.iterator();
            LinkData linkData;
            // Begins a transation.
            destRepositoryConn.begin();
            
            while (insertSetIterator.hasNext()) {
                linkData = (LinkData) insertSetIterator.next();
                subjectURI = linkData.getSubjectURI();
                objectURI = linkData.getObjectURI();
                // Adds the quad for the created link.
                destRepositoryConn.add(subjectURI, predicateURI, objectURI,
                        graphURI);                
            }
        }
        finally {
            try {
                // Commits the transation.
                destRepositoryConn.commit();
            }
            catch (Exception ex) {
            }
        }
    }
    
    /**
     * Gets the SPARQL query which will be used for the data retrieval from two
     * sources (named graphs).
     * @param linkSourceARepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * source data.
     * @param linkSourceBRepositoryName The name (alias) of the repository which
     * will be used to retrieve data from the named graph containing the link
     * destination data.
     * @param identifierType The type of the identifier to be used for the data
     * retrieval from the two named graphs.
     * @return The number of links created and saved.
     */
    private String getDataSelectionQuery(String linkSourceARepositoryName,
            String linkSourceBRepositoryName, IdentifierType identifierType) {
        String dataSelectionQuery = "";
        Identifier identifier = new Identifier();
        // The URI string of the named graph containing data of the link source.
        String graphAURIString = schema.getDataGraphURIString(
                linkSourceARepositoryName);
        // The URI string of the named graph containing data of the link
        // destination.
        String graphBURIString = schema.getDataGraphURIString(
                linkSourceBRepositoryName);
        // The identifier variable name which will be used to retrieve data from
        // the two named graphs.
        String varName = identifier.getIdentifierVariableName(identifierType);
        
        switch (identifierType) {
            // Category-A identifiers.
            case arXivID: case DOI: case ISBN: case LCCN: case OCLC: case PMID:
                dataSelectionQuery =
        "PREFIX prop: <" + schema.getPropertyPath() + ">                \n" +
        "                                                               \n" +
        "SELECT                                                         \n" +
        "    *                                                          \n" +
        "WHERE                                                          \n" +
        "    {                                                          \n" +
        "        GRAPH <" + graphAURIString + ">                        \n" +
        "            {?subjectA prop:" + varName + " ?" + varName + " . \n" +
        "             ?subjectA prop:title ?titleA .                    \n" +
        "             OPTIONAL {?subjectA prop:year ?yearA .}}          \n" +
        "        GRAPH <" + graphBURIString + ">                        \n" +
        "            {?subjectB prop:" + varName + " ?" + varName + " . \n" +
        "             ?subjectB prop:title ?titleB .                    \n" +
        "             OPTIONAL {?subjectB prop:year ?yearB .}}          \n" +
        "    }                                                          \n";
                break;
            // Category-B identifiers.
            case ISSN: case JournalTitle:
                dataSelectionQuery =
        "PREFIX prop: <" + schema.getPropertyPath() + ">                \n" +
        "                                                               \n" +
        "SELECT                                                         \n" +
        "    *                                                          \n" +
        "WHERE                                                          \n" +
        "    {                                                          \n" +
        "        GRAPH <" + graphAURIString + ">                        \n" +
        "            {?subjectA prop:" + varName + " ?" + varName + " . \n" +
        "             ?subjectA prop:title ?titleA .                    \n" +
        "             ?subjectA prop:year ?year .}                      \n" +
        "        GRAPH <" + graphBURIString + ">                        \n" +
        "            {?subjectB prop:" + varName + " ?" + varName + " . \n" +
        "             ?subjectB prop:title ?titleB .                    \n" +
        "             ?subjectB prop:year ?year .}                      \n" +
        "    }                                                          \n";
                break;
        }
        
        return dataSelectionQuery;
    }
    
    /**
     * Saves the links retrieved by the data selection query into the specified
     * file.
     * @param dataSelectionQuery A SPARQL query which will be used for the 
     * retrieval of the link triples.
     * @param exportPathname The path (including the filename) where the links
     * will be saved.
     */
    private void saveLinks(String dataSelectionQuery, String exportPathname) {
        TupleQueryResult queryResult = null;
        FileOutputStream fileOutputStream = null;
        OutputStreamWriter outputStreamWriter = null;
        
        try {
            boolean linksExist = false;
            BindingSet bindingSet;
            // Retrieves data from the destination repository.
            queryResult = destRepositoryConn.prepareTupleQuery(
                    QueryLanguage.SPARQL, dataSelectionQuery).evaluate();
            logger.logMessage("Exporting the links in file...",
                    MessageCategory.Info);
            String subjectString, predicateString, objectString, triple;
            File file = new File(exportPathname);
            // Checks for the existence of the file.
            if (file.exists() && !file.isDirectory())
                // Deletes the file.
                file.delete();
            // An output stream for the file.
            fileOutputStream = new FileOutputStream(exportPathname);
            // The file will be appended by using UTF-8 encoding.
            outputStreamWriter =
                    new OutputStreamWriter(fileOutputStream, "UTF8");
            
            while (queryResult.hasNext()) {
                linksExist = true;
                bindingSet = queryResult.next();
                // Reads the subject string of the link.
                subjectString = bindingSet.getBinding(
                        "subject").getValue().stringValue();
                // Reads the predicate string of the link.
                predicateString = bindingSet.getBinding(
                        "predicate").getValue().stringValue();
                // Reads the object string of the link.
                objectString = bindingSet.getBinding(
                        "object").getValue().stringValue();
                // Creates the string of the link triple.
                triple = "<" + subjectString + "> <" + predicateString +
                        "> <" + objectString + "> .";
                // Appends the file with the creates triple string.
                outputStreamWriter.append(triple + "\n");
            }
            
            if (linksExist)
                logger.logMessage("\tlinks saved successfully in file: \"" +
                        exportPathname + "\"", MessageCategory.Info);
            else
                logger.logMessage("\tno links found", MessageCategory.Info);
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
        finally {
            if (queryResult != null) {
                try {
                    queryResult.close();
                }
                catch (Exception ex) {
                }
            }
            if (outputStreamWriter != null) {
                try {
                    outputStreamWriter.close();
                }
                catch (Exception ex) {
                }    
            }
            if (fileOutputStream != null) {
                try {
                    fileOutputStream.close();
                }
                catch (Exception ex) {
                }
            }
        }    
    }
    
    /**
     * Checks if the provided subject URI strings must be rejected from the link
     * creation because of similarity.
     * @param subjectURIStringA A subject URI string.
     * @param subjectURIStringB A subject URI string.
     * @param resolveDOI Determines if doi.org URL resolving will be involved.
     * @return A value indicating if the two subject URI strings must be
     * rejected from the link creation because of similarity.
     */
    public boolean subjectURIsMustBeRejected(String subjectURIStringA,
            String subjectURIStringB, boolean resolveDOI) {
        boolean reject = false;
        
        try {
            // If the two subject URIs are the same, then they will be rejected
            // from the link creation.
            if (subjectURIStringA.equals(subjectURIStringB))
                return true;
            
            try {
                // Checks if the provided subject URI is a valid URL.
                new URL(subjectURIStringA);
                // Checks if the provided subject URI is a valid URL.
                new URL(subjectURIStringB);
            }
            catch (Exception ex) {
                return false;
            }
            
            if (resolveDOI) {
                // Gets the doi.org URL redirected address for the subject URI.
                subjectURIStringA = getDOIRedirectURLString(subjectURIStringA);
                // Gets the doi.org URL redirected address for the subject URI.
                subjectURIStringB = getDOIRedirectURLString(subjectURIStringB);
            }
            // Gets the host name for the subject URL.
            String subjectAHostName = new URL(subjectURIStringA).getHost();
            // Gets the host name for the subject URL.
            String subjectBHostName = new URL(subjectURIStringB).getHost();
            subjectAHostName = subjectAHostName.replace("www.", "");
            subjectBHostName = subjectBHostName.replace("www.", "");
            // If the two hosts are the same, then the URIs will be rejected
            // from the link creation.
            if (subjectAHostName.equals(subjectBHostName))
                reject = true;
        }
        catch (Exception ex) {
            reject = true;
        }
        
        return reject;
    }
    
    /**
     * Gets a doi.org redirected address for the provided URL string.
     * @param url The URL string.
     * @return The redirected address if there is one or otherwise the provided
     * URL string.
     */
    private String getDOIRedirectURLString(String url) {
        String urlString;
        
        try {
            // Download parameters.
            int connectTimeout = doiResolverDLParameterData.getConnectTimeout();
            int readTimeout = doiResolverDLParameterData.getReadTimeout();
            // Gets the host name from the provided URL string.
            String hostName = new URL(url).getHost();
            hostName = hostName.replace("www.", "");
            // If the host name doesn't contain either of the doi addresses then
            // it won't be checked for redirection.
            if (!(hostName.equals("doi.org") || hostName.equals("dx.doi.org")))
                return url;
            // Gets the path from the provided URL string.
            String pathPart = new URL(url).getPath();
            
            if (pathPart.length() == 0)
                return "";
            
            pathPart = pathPart.substring(1);
            URL doiURL = new URL("https://doi.org/api/handles/");
            String queryString = "?type=URL";
            // The URL that will be used to download the data.
            URL fileURL = new URL(doiURL, pathPart + queryString);
            // A file where the downloaded data will be saved.
            File file = new File(downloadPath.toString(), "doi_info.json");
            // Data download.
            FileUtils.copyURLToFile(fileURL, file, connectTimeout, readTimeout);
            // Gets the redirection address from the downloaded file.
            urlString = getURLString(file);
            consecutiveErrors = 0;
        }
        catch (java.io.FileNotFoundException ex) {
            urlString = url;
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Warning);
            consecutiveErrors++;
            return "";
        }
        
        return urlString;
    }
    
    /**
     * Gets the doi.org redirection address from a downloaded json file.
     * @param jsonFile The downloaded json file.
     * @return The redirection address.
     */
    private String getURLString(File jsonFile) {
        String urlString = "";
        FileOperation fileOperation = new FileOperation();
        
        try {    
            // Reads the content of the json file.
            String jsonString = fileOperation.getTextContent(jsonFile); 
            JSONObject jsonObject = new JSONObject(jsonString);
            int responseCode = jsonObject.getInt("responseCode");
            
            if (responseCode != 1)
                return "";
            
            JSONObject valuesObject =
                    jsonObject.getJSONArray("values").getJSONObject(0);
            // Reads the data object.
            JSONObject dataObject = valuesObject.getJSONObject("data");
            // Reads the redirection address.
            urlString = dataObject.getString("value");
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
        
        return urlString;
    }
    
    /**
     * Logs a message during the link creation depending on the value of the
     * linkMessageRecords variable.
     * @param logCount The number of times a message has been logged.
     * @param linkCount The number of links that have been created.
     * @param identifierName The name of the identifier to be logged.
     * @return The number of times a message has been logged.
     */
    private int logLinkMessage(int logCount, int linkCount,
            String identifierName) {
        if (logCount != linkCount / linkMessageRecords) {
            logCount = linkCount / linkMessageRecords;
            int links = logCount * linkMessageRecords;
            // A suffix for the word "record".
            String recordSuffix = (links == 1) ? "" : "s";
            logger.logMessage("\tlinked " + String.valueOf(links) + " " +
                    identifierName + " record" + recordSuffix,
                    MessageCategory.Info);
        }
        
        return logCount;
    }
    
    /**
     * Checks if the maximum number of consecutive errors has been exceeded.
     * @param consecutiveErrors The number of consecutive errors.
     * @param maxAllowedConsecutiveErrors The maximum allowed number of
     * consecutive errors.
     * @return A value indicating if the maximum number of consecutive errors
     * has been exceeded.
     */
    private boolean consecutiveErrorsExceedMaxAllowed(int consecutiveErrors,
            int maxAllowedConsecutiveErrors) {
        boolean errorsExceed = false;
        
        if (consecutiveErrors >= maxAllowedConsecutiveErrors) {
            logger.logMessage("the maximum number of consecutive " +
                    "errors allowed during link creation has been exceeded",
                    MessageCategory.Warning);
            errorsExceed = true;
        }
        
        return errorsExceed;
    }
    
    /**
     * Logs the missing necessary destination repository parameters.
     * @return A value indicating if a parameter is missing.
     */
    private boolean destRepositoryParameterMissing(
            RepositoryInfo destRepositoryInfo) {
        boolean parameterMissing = false;
        
        if (destRepositoryInfo == null) {
            this.logger.logMessage("destRepositoryInfo is null", 
                    MessageCategory.Warning);
            parameterMissing = true;
            return parameterMissing;
        }
        
        if (destRepositoryInfo.getRepositoryID().length() == 0) {
            this.logger.logMessage("destRepositoryInfo repositoryID not set",
                    MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (destRepositoryInfo.getServerURLString().length() == 0) {
            this.logger.logMessage("destRepositoryInfo serverURLString not set",
                    MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (destRepositoryInfo.getSchemaURLString().length() == 0) {
            this.logger.logMessage("destRepositoryInfo schemaURLString not set",
                    MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (destRepositoryInfo.getAuthenticationData() != null) {
            AuthenticationData authenticationData =
                    destRepositoryInfo.getAuthenticationData();
            
            if (authenticationData.getUsername().length() == 0) {
                this.logger.logMessage("destRepositoryInfo " + 
                        "authenticationData username not set",
                        MessageCategory.Warning);
                parameterMissing = true;
            }
            
            if (authenticationData.getPassword().length() == 0) {
                this.logger.logMessage("destRepositoryInfo " +
                        "authenticationData password not set",
                        MessageCategory.Warning);
                parameterMissing = true;
            }
        }
        
        return parameterMissing;
    }
}