/*
 * Copyright (C) 2017 David Nazarian
 *
 * This file is part of BibLinkCreator.
 *
 * BibLinkCreator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * BibLinkCreator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BibLinkCreator.  If not, see <http://www.gnu.org/licenses/>.
 */
package biblinkcreator;

import biblinkcreator.Logger.*;
import biblinkcreator.Identifier.*;
import biblinkcreator.DataStructure.*;
import java.io.*;
import java.net.URL;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;
import javax.xml.xpath.*;
import javax.xml.parsers.*;
import org.json.JSONObject;
import org.apache.commons.io.FileUtils;
import org.openrdf.model.*;
import org.openrdf.model.vocabulary.XMLSchema;
import org.openrdf.repository.*;
import org.openrdf.repository.http.HTTPRepository;
import org.openrdf.rio.RDFFormat;
import org.w3c.dom.*;

/**
 * A mechanism that downloads data by utilizing APIs from various bibliographic
 * sources and saves them into semantic repositories. <br><br>
 * Author: David Nazarian
 * @author David Nazarian
 */
public class DataDownloader {
    /**
     * An enumeration for the download APIs.
     */
    public enum SourceType {
        arXiv,
        HathiTrust,
        OpenLibrary,
        PubMed,
        WorldCat
    }
    // Number of queried identifiers needed for a message to be logged during
    // downloads.
    private int downloadMessageRecords = 1000;
    // Number of extracted records needed for a message to be logged during the
    // extraction.
    private int extractMessageRecords = 25000;
    // Download parameters for the APIs. For the rules and limitations (the
    // maximum number of identifiers in a single query, delay between
    // consecutive queries etc.) please consult each API's documentation.
    // https://arxiv.org/help/api/user-manual
    private APIDownloadParameterData arxivDLParameterData = 
            new APIDownloadParameterData(10000, 10000, 2000, 200, 3000, 20);
    // https://www.hathitrust.org/bib_api
    private APIDownloadParameterData hathitrustDLParameterData = 
            new APIDownloadParameterData(30000, 30000, 200, 20, 100, 20);
    // https://openlibrary.org/dev/docs/api/books
    private APIDownloadParameterData openlibraryDLParameterData = 
            new APIDownloadParameterData(30000, 30000, 2000, 200, 100, 20);
    // https://www.ncbi.nlm.nih.gov/books/NBK25497/
    private PubMedDownloadParameterData pubmedDLParameterData = 
            new PubMedDownloadParameterData(10000, 10000, 2000, 200, 340, 20,
                    "", "");
    // https://www.oclc.org/developer/develop/data-sets.en.html
    private WorldCatDownloadParameterData worldcatDLParameterData = 
            new WorldCatDownloadParameterData(5000, 5000, 500, 50, 100, 20,
                    2, 1000);
    // Repository connection to the source repository that will provide the
    // identifiers to be queried during the data downloading via an API.
    private RepositoryConnection sourceRepositoryConn = null;
    // Information about the source repository.
    private RepositoryInfo sourceRepositoryInfo = null;
    // The ID of the source repository set during its creation.
    private String sourceRepositoryID;
    // Logs messages generated by the methods of the class.
    private Logger logger = null;
    
    /**
     * @param sourceRepositoryInfo Information about the source repository that
     * will provide the identifiers to be queried during the data downloading
     * via an API.
     * @param logger A logger that will log generated messages.
     */
    public DataDownloader(RepositoryInfo sourceRepositoryInfo, Logger logger) {
        if (logger != null)
            this.logger = logger;
        else
            this.logger = new Logger(Logger.PrintType.None, "", false);
        // Logs the missing necessary repository parameters.
        if (sourceRepositoryParameterMissing(sourceRepositoryInfo))
            return;
        
        HTTPRepository sourceHTTPRepository;
        String sourceServerURLString =
                sourceRepositoryInfo.getServerURLString();
        Quadstore quadstore = new Quadstore();
        this.sourceRepositoryInfo = sourceRepositoryInfo;
        // The ID of the source repository set during its creation.
        this.sourceRepositoryID = sourceRepositoryInfo.getRepositoryID();
        // Checks for valid credentials for the source repository server.
        if (quadstore.isConnectionAuthorized(sourceServerURLString,
                sourceRepositoryInfo.getAuthenticationData(), logger) == false)
            return;
        
        try {
            sourceHTTPRepository = new HTTPRepository(sourceServerURLString,
                    sourceRepositoryID);
            quadstore.setAuthentication(
                    sourceRepositoryInfo.getAuthenticationData(),
                    sourceHTTPRepository);
            sourceRepositoryConn = sourceHTTPRepository.getConnection();
        }
        catch (Exception ex) {
            this.logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
    }
    
    /**
     * @return The number of queried identifiers needed for a message to be
     * logged during downloads.
     */
    public int getDownloadMessageRecords() {
        return downloadMessageRecords;
    }
    
    /**
     * @param downloadMessageRecords The number of queried identifiers needed
     * for a message to be logged during downloads.
     */
    public void setDownloadMessageRecords(int downloadMessageRecords) {
        this.downloadMessageRecords = downloadMessageRecords;
    }
    
    /**
     * @return The number of extracted records needed for a message to be logged
     * during the extraction.
     */
    public int getExtractMessageRecords() {
        return extractMessageRecords;
    }
    
    /**
     * @param extractMessageRecords The number of extracted records needed for
     * a message to be logged during the extraction.
     */
    public void setExtractMessageRecords(int extractMessageRecords) {
        this.extractMessageRecords = extractMessageRecords;
    }
    
    /**
     * @return The download parameters for the arXiv API.
     */
    public DownloadParameterData getArXivDownloadParameters() {
        return arxivDLParameterData;
    }
    
    /**
     * @param apiDownloadParameterData The download parameters for the arXiv
     * API.
     */
    public void setArXivDownloadParameters(
            APIDownloadParameterData apiDownloadParameterData) {
        this.arxivDLParameterData = apiDownloadParameterData;
    }
    
    /**
     * @return The download parameters for the HathiTrust API.
     */
    public DownloadParameterData getHathiTrustDownloadParameters() {
        return hathitrustDLParameterData;
    }
    
    /**
     * @param apiDownloadParameterData The download parameters for the 
     * HathiTrust API.
     */
    public void setHathiTrustDownloadParameters(
            APIDownloadParameterData apiDownloadParameterData) {
        this.hathitrustDLParameterData = apiDownloadParameterData;
    }
    
    /**
     * @return The download parameters for the Open Library API.
     */
    public DownloadParameterData getOpenLibraryDownloadParameters() {
        return openlibraryDLParameterData;
    }
    
    /**
     * @param apiDownloadParameterData The download parameters for the 
     * Open Library API.
     */
    public void setOpenLibraryDownloadParameters(
            APIDownloadParameterData apiDownloadParameterData) {
        this.openlibraryDLParameterData = apiDownloadParameterData;
    } 
    
    /**
     * @return The download parameters for the PubMed API.
     */
    public PubMedDownloadParameterData getPubMedDownloadParameters() {
        return pubmedDLParameterData;
    }
    
    /**
     * @param pubmedDownloadParameterData The download parameters for the PubMed
     * API.
     */
    public void setPubMedParameters(
            PubMedDownloadParameterData pubmedDownloadParameterData) {
        this.pubmedDLParameterData = pubmedDownloadParameterData;
    }
    
    /**
     * @return The download parameters for the WorldCat API.
     */
    public WorldCatDownloadParameterData getWorldCatDownloadParameters() {
        return worldcatDLParameterData;
    }
    
    /**
     * @param worldcatDownloadParameterData The download parameters for the 
     * WorldCat API.
     */
    public void setWorldCatDownloadParameters(
            WorldCatDownloadParameterData worldcatDownloadParameterData) {
        this.worldcatDLParameterData = worldcatDownloadParameterData;
    }
    
    /**
     * Closes the connection to the source repository providing the identifiers
     * to be queried during the data downloading via an API.
     */
    public void close() {
        try {
            sourceRepositoryConn.close();
        }
        catch (RepositoryException ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
    }
    
    /**
     * Downloads data via an API and returns the number of downloaded records.
     * @param extractionQueryA A SPARQL query which will extract the identifiers
     * from the source repository, to be queried and downloaded via an API. Its
     * select clause must contain a variable with the name of the identifier,
     * e.g. ?isbn. The variable names for the identifiers can be retrieved by
     * using the getIdentifierVariableName method of the Identifier class.
     * @param extractionQueryB A SPARQL query which will extract the identifiers
     * from the destination repository (a repository containing already
     * downloaded data) so that they are excluded from the downloads. Its select
     * clause must contain a variable with the name of the identifier.
     * @param destRepositoryInfo Information about the destination repository
     * where the downloaded records will be transferred to.
     * @param sourceType The download API to be used.
     * @param identifierType The type of the queried identifier.
     * @param sourceStringFormatData (Optional) Extra preprocessing information
     * for the identifiers extracted from the source repository.
     * @param destStringFormatData (Optional) Extra preprocessing information
     * for the identifiers extracted from the destination repository.
     * @return The number of downloaded records.
     */
    public int downloadData(String extractionQueryA, String extractionQueryB,
            RepositoryInfo destRepositoryInfo, SourceType sourceType,
            IdentifierType identifierType,
            StringFormatData sourceStringFormatData,
            StringFormatData destStringFormatData) {
        int downloadCount = 0;
        // Logs the missing necessary repository parameters.
        if (sourceRepositoryParameterMissing(sourceRepositoryInfo) |
                destRepositoryParameterMissing(destRepositoryInfo))
            return downloadCount;
        
        HTTPRepository destHTTPRepository;
        RepositoryConnection destRepositoryConn;
        Schema schema = new Schema(destRepositoryInfo.getSchemaURLString());
        String destServerURLString = destRepositoryInfo.getServerURLString();
        // The ID of the destination repository set during its creation.
        String destRepositoryID = destRepositoryInfo.getRepositoryID();
        String sourceServerURLString =
                sourceRepositoryInfo.getServerURLString();
        Quadstore quadstore = new Quadstore();
        // Checks for valid credentials for the source repository server.
        if (quadstore.isConnectionAuthorized(sourceServerURLString,
                sourceRepositoryInfo.getAuthenticationData(),
                logger) == false)
            return downloadCount;
        // Checks for valid credentials for the destination repository server.
        if (quadstore.isConnectionAuthorized(destServerURLString,
                destRepositoryInfo.getAuthenticationData(),
                logger) == false)
            return downloadCount;

        try {    
            destHTTPRepository = 
                    new HTTPRepository(destServerURLString, destRepositoryID);
            quadstore.setAuthentication(
                    destRepositoryInfo.getAuthenticationData(),
                    destHTTPRepository);
            destRepositoryConn = destHTTPRepository.getConnection();
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            return downloadCount;
        }
        // Checks for missing authentication data if the PubMed API is selected.
        if (sourceType == SourceType.PubMed &&
                pubmedAuthenticationMissing(pubmedDLParameterData))
            return downloadCount;
        // Checks for the validity of the selected API and identifier
        // combination.
        if (isSourceIdentifierCombinationValid(
                sourceType, identifierType) == false) {
            logger.logMessage("Invalid combination of sourceType and " +
                    "identifierType specified", MessageCategory.Warning);
            return downloadCount;
        }
        
        Identifier identifier = new Identifier();
        String identifierName = identifier.getIdentifierName(identifierType);
        // An extractor that will retrieve the identifiers to be queried for
        // data downloading via an API.
        DataExtractor dataExtractor = new DataExtractor(sourceRepositoryInfo,
                destRepositoryInfo, null, logger);
        // Sets the number of extracted records needed for a message to be
        // logged during the extraction.
        dataExtractor.setExtractMessageRecords(extractMessageRecords);
        Set<String> existingIdentifierSet;
        
        logger.logMessage("Preparing to download data for repository " +
                destRepositoryID + "...", MessageCategory.Info);
        logger.logMessage("Retrieving " + identifierName +
                " data from repository " + destRepositoryID +
                "...", MessageCategory.Info);
        // Extracts the existing identifier set from the destination repository.
        existingIdentifierSet = dataExtractor.getIdentifierSet(
                extractionQueryB, destRepositoryConn, identifierType,
                true, destStringFormatData);
        // The set is null in case of an error during the extraction.
        if (existingIdentifierSet == null)
            return downloadCount;
        
        logger.logMessage("\trecords found : " + String.valueOf(
                existingIdentifierSet.size()), MessageCategory.Info);
        logger.logMessage("Extracting " + identifierName + 
                " data from repository " + sourceRepositoryID + "...",
                MessageCategory.Info);
        // Extracts the identifiers from the source repository, excluding the
        // already existing set retrieved from the destination repository.
        ExtractionResult extractionResultA = 
                dataExtractor.getFormattedIdentifierSet(extractionQueryA,
                sourceRepositoryConn, null, existingIdentifierSet,
                identifierType, sourceStringFormatData);
        // The result is null in case of an error during the extraction.
        if (extractionResultA == null ||
                extractionResultA.getIdentifierSet().isEmpty())
            return downloadCount;
        
        logger.logMessage("\ttotal unique records found : " +
                String.valueOf(extractionResultA.getIdentifierSet().size()),
                MessageCategory.Info);
        // The identifier set that will be used to query and download data via
        // an API.
        Set<String> identifierSet = extractionResultA.getIdentifierSet();
        // Data download will occur based on the selected API source.
        switch (sourceType) {
            case arXiv:
                downloadCount = downloadArXivData(identifierSet,
                        identifierType, destRepositoryConn, schema);
                break;
            case HathiTrust:
                downloadCount = downloadHathiTrustData(identifierSet,
                        identifierType, destRepositoryConn, schema);
                break;
            case OpenLibrary:
                downloadCount = downloadOpenLibraryData(identifierSet,
                        identifierType, destRepositoryConn, schema);
                break;
            case PubMed:
                downloadCount = downloadPubMedData(identifierSet,
                        identifierType, destRepositoryConn, schema);
                break;
            case WorldCat:
                downloadCount = downloadWorldCatData(identifierSet,
                        identifierType, destRepositoryConn);
                break;
        }
        
        return downloadCount;
    }
    
    /**
     * Downloads data via the arXiv API. For the rules and limitations (the
     * maximum number of identifiers in a single query, delay between
     * consecutive queries etc.) please consult the API's documentation
     *  <a href="https://arxiv.org/help/api/user-manual">
     *  https://arxiv.org/help/api/user-manual</a><br>
     * The API must be used only after conformity with the specified rules.
     * @param identifierSet A set of identifiers to be queried.
     * @param identifierType The type of the queried identifier.
     * @param destRepositoryConn Connection to the destination repository where
     * the downloaded data will be saved.
     * @param schema Provides structure for the saved data.
     * @return The number of downloaded records.
     */
    public int downloadArXivData(Set<String> identifierSet,
            IdentifierType identifierType,
            RepositoryConnection destRepositoryConn, Schema schema) {
        int downloadCount = 0;
        // The API can only be used to query arXiv IDs. For information about
        // the ID structure check the following link
        // https://arxiv.org/help/arxiv_identifier
        if (identifierType != IdentifierType.arXivID)
            return downloadCount;
        // Download parameters.
        int connectTimeout = arxivDLParameterData.getConnectTimeout();
        int readTimeout = arxivDLParameterData.getReadTimeout();
        int insertBatchSize = arxivDLParameterData.getInsertBatchSize();
        int downloadBatchSize = arxivDLParameterData.getDownloadBatchSize();
        int downloadDelay = arxivDLParameterData.getDownloadDelay();
        int maxAllowedConsecutiveErrors =
                arxivDLParameterData.getMaxAllowedConsecutiveErrors();
        int logCount = 0;
        
        FileOperation fileOperation = new FileOperation();
        Identifier identifier = new Identifier();
        // An identifier name for logging.
        String identifierName = identifier.getIdentifierName(identifierType);
        // An identifier name for variables.
        String identifierVariableName =
                identifier.getIdentifierVariableName(identifierType);
        URL apiURL;
        Path downloadPath;
        
        logger.logMessage("Downloading " + identifierName + 
                " data from arXiv...", MessageCategory.Info);
        
        try {
            apiURL = new URL("http://export.arxiv.org/api/");
            // Creates a temporary download folder.
            downloadPath = Files.createTempDirectory("biblc_arxiv_" +
                    identifierVariableName + "_");
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            return downloadCount;
        }
        
        String queryString = "query?&max_results=" + downloadBatchSize +
                "&id_list=";
        // The base URL that will be used to create the subjects. A subject URI
        // will be generated after concatenating the base URL with an arxivID.
        String arxivURLString = "https://arxiv.org/abs/";
        URL fileURL;
        File file;
        String filename;
        List<ExtractedData> collectiveList = new ArrayList<>();
        // A set of versioned arXiv IDs.
        Set<String> versionedIdentifierSet =
                getVersionedArXivIDSet(identifierSet);
        // A set of non-versioned arXiv IDs.
        Set<String> nonVersionedIdentifierSet = new HashSet<>();
        nonVersionedIdentifierSet.addAll(identifierSet);
        nonVersionedIdentifierSet.removeAll(versionedIdentifierSet);
        
        boolean excludeVersion = false;
        // A list that contains delimited identifier chains and a count for the
        // identifiers present in each chain.
        List<IdentifierChainData> identifierChainDataList = new ArrayList<>();
        int consecutiveErrors = 0;
        int queryCount = 0;
        IdentifierChainData identifierChainData;
        String identifierChain ;
        int identifierCount;
        long startTime;
        
        // The versioned and non-versioned identifiers are queried separately.
        for (int i = 1; i <= 2; i++) {
            switch (i) {
                case 1:
                    // Creation of a versioned identitfier chain data list.
                    identifierChainDataList = getIdentifierChainDataList(
                            versionedIdentifierSet, "", "", ",",
                            downloadBatchSize);
                    break;
                case 2:
                    // Creation of a non-versioned identitfier chain data list.
                    identifierChainDataList = getIdentifierChainDataList(
                            nonVersionedIdentifierSet, "", "", ",",
                            downloadBatchSize);
                    excludeVersion = true;
                    break;
                default:
                    break;
            }
            
            for (int j = 0; j < identifierChainDataList.size(); j++) {
                if (consecutiveErrorsExceedMaxAllowed(consecutiveErrors,
                        maxAllowedConsecutiveErrors))
                    return downloadCount;
                // Begins the timing of the duration between consecutive
                // queries.
                startTime = System.currentTimeMillis();
                // The name of the temporary file where the downloaded content
                // will be saved.
                filename = "batch_" + (j + 1) + ".xml";
                identifierChainData = identifierChainDataList.get(j);
                // The delimited identifier chain.
                identifierChain = identifierChainData.getIdentifierChain();
                // The number of identifiers in the chain.
                identifierCount = identifierChainData.getIdentifierCount();
                
                try {
                    // The URL that will be used to download the data.
                    fileURL = new URL(apiURL, queryString + identifierChain);
                }
                catch (Exception ex) {
                    logger.logMessage(ex.getMessage(), MessageCategory.Error);
                    consecutiveErrors++;
                    continue;
                }
                // A file where the downloaded data will be saved.
                file = new File(downloadPath.toString(), filename);
                
                try {
                    queryCount += identifierCount;
                    // Data download.
                    FileUtils.copyURLToFile(fileURL, file, connectTimeout,
                            readTimeout);
                    // The variable is initialized after a successful download.
                    consecutiveErrors = 0;
                }
                catch (Exception ex) {
                    logger.logMessage(ex.getMessage(), MessageCategory.Error);
                    consecutiveErrors++;
                    continue;
                }
                // Reads the downloaded file's content.
                List<ExtractedData> extractedDataList =
                        getArXivData(file, excludeVersion);
                collectiveList.addAll(extractedDataList);
                downloadCount += extractedDataList.size();
                fileOperation.deleteTempFile(file);
                // The collected content will be sent to the repository as a
                // batch.
                if (collectiveList.size() >= insertBatchSize) {
                    if (executeTransaction(collectiveList, arxivURLString,
                            identifierVariableName, destRepositoryConn,
                            schema) == false)
                        return downloadCount;
                    
                    collectiveList.clear();
                }
                // A message will be logged based on the downloadMessageRecords
                // value.
                logCount = logDownloadMessage(logCount, queryCount,
                        downloadCount, identifierName);
                // Delay between consecutive downloads
                delayDownload(startTime, downloadDelay);
            }
            // The remaining content will be sent to the repository.
            if (collectiveList.size() > 0) {
                if (executeTransaction(collectiveList, arxivURLString,
                        identifierVariableName, destRepositoryConn,
                        schema) == false)
                    return downloadCount;
                
                collectiveList.clear();
            }
        }
        // Deletes the temporary download folder.
        fileOperation.deleteTempFolder(downloadPath);
        logger.logMessage("\ttotal records downloaded and saved : " +
                String.valueOf(downloadCount), MessageCategory.Info);
        
        return downloadCount;
    }
    
    /**
     * Extracts the content of a file downloaded via the arXiv API.
     * @param xmlFile The downloaded xml file.
     * @param excludeVersion Excludes the version from the arXiv ID.
     * @return An extracted data list.
     */
    private List<ExtractedData> getArXivData(File xmlFile,
            boolean excludeVersion) {
        List<ExtractedData> downloadedDataList = new ArrayList<>();
        NodeList feedNodeList;
        
        try {
            DocumentBuilderFactory builderFactory =
                    DocumentBuilderFactory.newInstance();
            // Prevents the default validation of the file's structure.
            builderFactory.setFeature("http://apache.org/xml/features/" +
                    "nonvalidating/load-external-dtd", false);
            DocumentBuilder builder = builderFactory.newDocumentBuilder();
            // Reads the file.
            Document xmlDocument = builder.parse(xmlFile);
            XPath xPath =  XPathFactory.newInstance().newXPath();
            // XPath expression to retrieve an element.
            String expression = "/feed/entry";
            feedNodeList = (NodeList) xPath.evaluate(expression, xmlDocument,
                    XPathConstants.NODESET);
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Warning);
            return downloadedDataList;
        }
        
        String childNodeName;
        String arxivID = "";
        String title = "";
        String year = "";   
        String version;
        // Iteration through all the results retrieved.
        for (int i = 0; i < feedNodeList.getLength(); i++) {
            try {
                Node entryNode = feedNodeList.item(i);
                
                if (entryNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element entryElement = (Element) entryNode;
                    NodeList entryChildNodeList = entryElement.getChildNodes();
                    
                    for (int j = 0; j < entryChildNodeList.getLength(); j++) {   
                        Node entryChildNode = (Node) entryChildNodeList.item(j);
                        childNodeName = entryChildNode.getNodeName();                        
                        
                        switch (childNodeName) {
                            case "id":
                                arxivID = entryChildNode.getTextContent();
                                // Separates the ID from the URL.
                                arxivID = arxivID.replace(
                                        "http://arxiv.org/abs/", "");
                                arxivID = arxivID.replace(
                                        "https://arxiv.org/abs/", "");
                                // Removes the version from the ID.
                                if (excludeVersion) {
                                    version = getArXivIDVersion(arxivID);
                                    version = "v" + version;
                                    arxivID = arxivID.replace(version, "");
                                }
                                
                                break;
                            case "title":
                                // Reads the title.
                                title = entryChildNode.getTextContent();                               
                                break;
                            case "published":
                                year = entryChildNode.getTextContent();
                                // Separates the publication year.
                                year = year.substring(0, 4);
                                break;
                        }
                        // The ID and the title are the minimum necessary data.
                        if (arxivID.length() > 0 && title.length() > 0) {
                            if (!title.equals("Error"))
                                downloadedDataList.add(new ExtractedData(
                                        "", arxivID, title, year));
                            
                            break;
                        }
                    }
                    
                    arxivID = "";
                    title = "";
                    year = "";
                }
            }
            catch (Exception ex) {
            }
        }
        
        return downloadedDataList;
    }
    
    /**
     * Gets the version of the arXiv ID.
     * @param arxivID The arXiv ID.
     * @return The version of the arXiv ID.
     */
    private String getArXivIDVersion(String arxivID) {
        String version = "";
        // Two parts will result only for the IDs assigned before April 1st
        // 2007.
        String[] arxivIDPartsA = arxivID.split("/");
        String[] arxivIDPartsB;
        
        switch (arxivIDPartsA.length) {
            case 1:
                // Version for ID assigned since April 1st 2007.
                arxivIDPartsB = arxivIDPartsA[0].split("v");
                break;
            case 2:
                // Version for ID assigned before April 1st 2007.
                arxivIDPartsB = arxivIDPartsA[1].split("v");
                break;
            default:
                return version;
        }
        
        if (arxivIDPartsB.length == 2)
            version = arxivIDPartsB[1];
        
        return version;
    }
    
    /**
     * Gets the versioned portion of the arXiv ID set.
     * @param arxivIDSet A set of mixed arXiv IDs.
     * @return The versioned portion of the arXiv ID set.
     */
    private Set<String> getVersionedArXivIDSet(Set<String> arxivIDSet) {
        Set<String> versionedSet = new HashSet<>();
        String arxivID, version;
        Iterator arxivIDIterator = arxivIDSet.iterator();
        
        while (arxivIDIterator.hasNext()) {
            arxivID = (String) arxivIDIterator.next();
            // Gets the version of the arXiv ID.
            version = getArXivIDVersion(arxivID);
            // Adds the version (if exists) to the resulting set.
            if (version.length() > 0)
                versionedSet.add(arxivID);
        }
        
        return versionedSet;
    }
    
    /**
     * Downloads data via the HathiTrust API. For the rules and limitations (the
     * maximum number of identifiers in a single query, delay between
     * consecutive queries etc.) please consult the API's documentation 
     *  <a href="https://www.hathitrust.org/bib_api">
     *  https://www.hathitrust.org/bib_api</a><br>
     * The API must be used only after conformity with the specified rules.
     * @param identifierSet A set of identifiers to be queried.
     * @param identifierType The type of the queried identifier.
     * @param destRepositoryConn Connection to the destination repository where
     * the downloaded data will be saved.
     * @param schema Provides structure for the saved data.
     * @return The number of downloaded records.
     */
    public int downloadHathiTrustData(Set<String> identifierSet,
            IdentifierType identifierType,
            RepositoryConnection destRepositoryConn, Schema schema) {
        int downloadCount = 0;
        // The API can only be used to query ISBN, OCLC and LCCN identifiers.
        // For information about the structure of these identifier, check the
        // following links
        // ISBN: https://www.isbn-international.org/sites/default/files/
        //       ISBN%20Manual%202012%20-corr.pdf
        // OCLC: https://www.oclc.org/batchload/controlnumber.en.html
        // LCCN: https://www.loc.gov/marc/lccn_structure.html 
        //       https://www.loc.gov/marc/lccn-namespace.html
        if (identifierType != IdentifierType.ISBN &&
            identifierType != IdentifierType.OCLC &&
            identifierType != IdentifierType.LCCN) {
            return downloadCount;
        }
        // Download parameters.
        int connectTimeout = hathitrustDLParameterData.getConnectTimeout();
        int readTimeout = hathitrustDLParameterData.getReadTimeout();
        int insertBatchSize = hathitrustDLParameterData.getInsertBatchSize();
        int downloadBatchSize = hathitrustDLParameterData.getDownloadBatchSize();
        int downloadDelay = hathitrustDLParameterData.getDownloadDelay();
        int maxAllowedConsecutiveErrors =
                hathitrustDLParameterData.getMaxAllowedConsecutiveErrors();
        int logCount = 0;
        
        FileOperation fileOperation = new FileOperation();
        Identifier identifier = new Identifier();
        // An identifier name for logging.
        String identifierName = identifier.getIdentifierName(identifierType);
        // An identifier name for variables.
        String identifierVariableName =
                identifier.getIdentifierVariableName(identifierType);
        URL apiURL;
        Path downloadPath;
        
        logger.logMessage("Downloading " + identifierName + 
                " data from HathiTrust...", MessageCategory.Info);
        
        try {
            apiURL = new URL("https://catalog.hathitrust.org/");
            // Creates a temporary download folder.
            downloadPath = Files.createTempDirectory("biblc_hathitrust_" +
                    identifierVariableName + "_");
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            return downloadCount;
        }
        
        String apiPathString = "api/volumes/brief/json/";
        URL fileURL;
        File file;
        String filename;
        List<ExtractedData> collectiveList = new ArrayList<>();
        // A list that contains delimited identifier chains and a count for the
        // identifiers present in each chain.
        List<IdentifierChainData> identifierChainDataList =
                getIdentifierChainDataList(identifierSet,
                        identifierVariableName + ":", "", "|",
                        downloadBatchSize);
        int consecutiveErrors = 0;
        int queryCount = 0;
        IdentifierChainData identifierChainData;
        String identifierChain ;
        int identifierCount;
        long startTime;
        
        for (int i = 0; i < identifierChainDataList.size(); i++) {           
            if (consecutiveErrorsExceedMaxAllowed(consecutiveErrors,
                    maxAllowedConsecutiveErrors))
                return downloadCount;
            // Begins the timing of the duration between consecutive queries.
            startTime = System.currentTimeMillis();
            // The name of the temporary file where the downloaded content will
            // be saved.
            filename = "batch_" + (i + 1) + ".json";
            identifierChainData = identifierChainDataList.get(i);
            // The delimited identifier chain.
            identifierChain = identifierChainData.getIdentifierChain();
            // The number of identifiers in the chain.
            identifierCount = identifierChainData.getIdentifierCount();
            
            try {
                // The URL that will be used to download the data.
                fileURL = new URL(apiURL, apiPathString + identifierChain);
            }
            catch (Exception ex) {
                logger.logMessage(ex.getMessage(), MessageCategory.Error);
                consecutiveErrors++;
                continue;
            }
            // A file where the downloaded data will be saved.
            file = new File(downloadPath.toString(), filename);
            
            try {
                queryCount += identifierCount; 
                // Data download.
                FileUtils.copyURLToFile(fileURL, file, connectTimeout,
                        readTimeout);
                // The variable is initialized after a successful download.
                consecutiveErrors = 0;
            }
            catch (Exception ex) {
                logger.logMessage(ex.getMessage(), MessageCategory.Error);
                consecutiveErrors++;
                continue;
            }
            // Reads the downloaded file's content.
            List<ExtractedData> extractedDataList =
                    getHathiTrustData(file, identifierVariableName);
            collectiveList.addAll(extractedDataList);
            downloadCount += extractedDataList.size();
            fileOperation.deleteTempFile(file);
            // The collected content will be sent to the repository as a batch.
            if (collectiveList.size() >= insertBatchSize) {
                if (executeTransaction(collectiveList, "",
                        identifierVariableName, destRepositoryConn,
                        schema) == false)
                    return downloadCount;
                
                collectiveList.clear();
            }
            // A message will be logged based on the downloadMessageRecords
            // value.
            logCount = logDownloadMessage(logCount, queryCount, downloadCount,
                    identifierName);
            // Delay between consecutive downloads.
            delayDownload(startTime, downloadDelay);
        }
        // The remaining content will be sent to the repository.
        if (collectiveList.size() > 0) {
            if (executeTransaction(collectiveList, "", identifierVariableName,
                    destRepositoryConn, schema) == false)
                return downloadCount;
            
            collectiveList.clear();
        }
        // Deletes the temporary download folder.
        fileOperation.deleteTempFolder(downloadPath);
        logger.logMessage("\ttotal records downloaded and saved : " +
                String.valueOf(downloadCount), MessageCategory.Info);
        
        return downloadCount;
    }
    
    /**
     * Extracts the content of a file downloaded via the HathiTrust API.
     * @param jsonFile The downloaded json file.
     * @param identifierVariableName The identifier variable name.
     * @return An extracted data list.
     */
    private List<ExtractedData> getHathiTrustData(File jsonFile,
            String identifierVariableName) {
        List<ExtractedData> downloadedDataList = new ArrayList<>();
        Iterator jsonIterator;
        JSONObject jsonObject;
        FileOperation fileOperation = new FileOperation();
        
        try {
            // Reads the content of the json file.
            String jsonString = fileOperation.getTextContent(jsonFile);
            jsonObject = new JSONObject(jsonString);
            jsonIterator = jsonObject.keys();
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            return downloadedDataList;
        }
        
        String rootKey;
        String catalogID;
        String subject;
        identifierVariableName += ":";
        List<Object> titleList;
        List<Object> yearList = new ArrayList<>();
        
        while (jsonIterator.hasNext()) {
            rootKey = (String)jsonIterator.next();
            JSONObject recordsObject;
            
            try {
                // Reads the records object.
                recordsObject = jsonObject.getJSONObject(
                        rootKey).getJSONObject("records");
            }
            catch (Exception ex) {
                // If a records object not found.
                continue;
            }
            
            Iterator recordsIterator = recordsObject.keys();
            
            while (recordsIterator.hasNext()) {
                catalogID = (String)recordsIterator.next();
                
                try {
                    // Reads the subject url.
                    subject = recordsObject.getJSONObject(
                            catalogID).getString("recordURL");
                    // Reads the title.
                    titleList = recordsObject.getJSONObject(
                            catalogID).getJSONArray("titles").toList();
                }
                catch (Exception ex) {
                    // If a subject or a title not found.
                    continue;
                }
                
                try {
                    // Reads the publication year list.
                    yearList = recordsObject.getJSONObject(
                            catalogID).getJSONArray("publishDates").toList();
                }
                catch (Exception ex) {
                }
                // The identifier to be added.
                rootKey = rootKey.replace(identifierVariableName, "");
                addIdentifierItems(downloadedDataList, subject, rootKey,
                        titleList, yearList);
            }
        }
        
        return downloadedDataList;
    }
    
    /**
     * Adds an extracted item downloaded via the HathiTrust API to a data list.
     * @param dataList The data list where the extracted data will be added.
     * @param subject The subject URL.
     * @param identifier The identifier.
     * @param titleList A list of extracted titles for a single identifier.
     * @param yearList A list of extracted publication years for a single
     * identifier.
     */
    private void addIdentifierItems(List<ExtractedData> dataList,
            String subject, String identifier, List<Object> titleList,
            List<Object> yearList) {
        String title, year;
        // A title is necessary for the extracted data.
        if (titleList.size() > 0) {
            // Publication year is optional for the extracted data.
            if (yearList.size() > 0) {
                for (int i = 0; i < titleList.size(); i++) {
                    title = titleList.get(i).toString();
                    
                    for (int j = 0; j < yearList.size(); j++) {
                        year = yearList.get(j).toString();
                        // A combination of title and publication year is added
                        // to the list.
                        dataList.add(new ExtractedData(subject, identifier,
                                title, year));
                    }
                }
            }
            else {
                for (int i = 0; i < titleList.size(); i++) {
                    title = titleList.get(i).toString();
                    // The title is added to the list.
                    dataList.add(new ExtractedData(subject, identifier,
                            title, ""));
                }
            }
        }
    }
    
    /**
     * Downloads data via the Open Library API. For the rules and limitations
     * (the maximum number of identifiers in a single query, delay between
     * consecutive queries etc.) please consult the API's documentation 
     *  <a href="https://openlibrary.org/dev/docs/api/books">
     *  https://openlibrary.org/dev/docs/api/books</a><br>
     * The API must be used only after conformity with the specified rules.
     * @param identifierSet A set of identifiers to be queried.
     * @param identifierType The type of the queried identifier.
     * @param destRepositoryConn Connection to the destination repository where
     * the downloaded data will be saved.
     * @param schema Provides structure for the saved data.
     * @return The number of downloaded records.
     */
    public int downloadOpenLibraryData(Set<String> identifierSet,
            IdentifierType identifierType,
            RepositoryConnection destRepositoryConn, Schema schema) {
        int downloadCount = 0;
        // The API can only be used to query ISBN, OCLC and LCCN identifiers.
        // For information about the structure of these identifier, check the
        // following links
        // ISBN: https://www.isbn-international.org/sites/default/files/
        //       ISBN%20Manual%202012%20-corr.pdf
        // OCLC: https://www.oclc.org/batchload/controlnumber.en.html
        // LCCN: https://www.loc.gov/marc/lccn_structure.html 
        //       https://www.loc.gov/marc/lccn-namespace.html
        if (identifierType != IdentifierType.ISBN &&
            identifierType != IdentifierType.OCLC &&
            identifierType != IdentifierType.LCCN) {
            return downloadCount;
        }
        // Download parameters.
        int connectTimeout = openlibraryDLParameterData.getConnectTimeout();
        int readTimeout = openlibraryDLParameterData.getReadTimeout();
        int insertBatchSize = openlibraryDLParameterData.getInsertBatchSize();
        int downloadBatchSize = openlibraryDLParameterData.getDownloadBatchSize();
        int downloadDelay = openlibraryDLParameterData.getDownloadDelay();
        int maxAllowedConsecutiveErrors =
                openlibraryDLParameterData.getMaxAllowedConsecutiveErrors();
        int logCount = 0;
        
        FileOperation fileOperation = new FileOperation();
        Identifier identifier = new Identifier();
        // An identifier name for logging.
        String identifierName = identifier.getIdentifierName(identifierType);
        // An identifier name for variables.
        String identifierVariableName =
                identifier.getIdentifierVariableName(identifierType);
        URL apiURL;
        Path downloadPath;
        
        logger.logMessage("Downloading " + identifierName + 
                " data from Open Library...", MessageCategory.Info);
        
        try {
            apiURL = new URL("https://openlibrary.org/api/");
            // Creates a temporary download folder.
            downloadPath = Files.createTempDirectory("biblc_openlibrary_" +
                    identifierVariableName + "_");
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            return downloadCount;
        }
        
        String queryString = "books?jscmd=data&format=json&bibkeys=";
        URL fileURL;
        File file;
        String filename;
        List<ExtractedData> collectiveList = new ArrayList<>();
        // A list that contains delimited identifier chains and a count for the
        // identifiers present in each chain.
        List<IdentifierChainData> identifierChainDataList =
                getIdentifierChainDataList(identifierSet, 
                        identifierVariableName + ":", "", ",",
                        downloadBatchSize);
        int consecutiveErrors = 0;
        int queryCount = 0;
        IdentifierChainData identifierChainData;
        String identifierChain ;
        int identifierCount;
        long startTime;
        
        for (int i = 0; i < identifierChainDataList.size(); i++) {
            if (consecutiveErrorsExceedMaxAllowed(consecutiveErrors,
                    maxAllowedConsecutiveErrors))
                return downloadCount;
            // Begins the timing of the duration between consecutive queries.
            startTime = System.currentTimeMillis();
            // The name of the temporary file where the downloaded content will
            // be saved.
            filename = "batch_" + (i + 1) + ".json";
            
            identifierChainData = identifierChainDataList.get(i);
            // The delimited identifier chain.
            identifierChain = identifierChainData.getIdentifierChain();
            // The number of identifiers in the chain.
            identifierCount = identifierChainData.getIdentifierCount();
            
            try {
                // The URL that will be used to download the data.
                fileURL = new URL(apiURL, queryString + identifierChain);
            }
            catch (Exception ex) {
                logger.logMessage(ex.getMessage(), MessageCategory.Error);
                consecutiveErrors++;
                continue;
            }
            // A file where the downloaded data will be saved.
            file = new File(downloadPath.toString(), filename);
            
            try {
                queryCount += identifierCount;
                // Data download.
                FileUtils.copyURLToFile(fileURL, file, connectTimeout,
                        readTimeout);
                // The variable is initialized after a successful download.
                consecutiveErrors = 0;
            }
            catch (Exception ex) {
                logger.logMessage(ex.getMessage(), MessageCategory.Error);
                consecutiveErrors++;
                continue;
            }
            // Reads the downloaded file's content.
            List<ExtractedData> extractedDataList =
                    getOpenLibraryData(file, identifierVariableName);
            collectiveList.addAll(extractedDataList);
            downloadCount += extractedDataList.size();
            fileOperation.deleteTempFile(file);
            // The collected content will be sent to the repository as a batch.
            if (collectiveList.size() >= insertBatchSize) {
                if (executeTransaction(collectiveList, "",
                        identifierVariableName, destRepositoryConn,
                        schema) == false)
                    return downloadCount;
                
                collectiveList.clear();
            }
            // A message will be logged based on the downloadMessageRecords
            // value.
            logCount = logDownloadMessage(logCount, queryCount, downloadCount,
                    identifierName);
            delayDownload(startTime, downloadDelay);
        }
        // The remaining content will be sent to the repository.
        if (collectiveList.size() > 0) {
            if (executeTransaction(collectiveList, "", identifierVariableName,
                    destRepositoryConn, schema) == false)
                return downloadCount;
            
            collectiveList.clear();
        }
        // Deletes the temporary download folder.
        fileOperation.deleteTempFolder(downloadPath);
        logger.logMessage("\ttotal records downloaded and saved : " +
                String.valueOf(downloadCount), MessageCategory.Info);
        
        return downloadCount;
    }
    
    /**
     * Extracts the content of a file downloaded via the Open Library API.
     * @param jsonFile The downloaded json file.
     * @param identifierVariableName The identifier variable name.
     * @return An extracted data list.
     */
    private List<ExtractedData> getOpenLibraryData(File jsonFile,
            String identifierVariableName) {
        List<ExtractedData> downloadedDataList = new ArrayList<>();
        Iterator jsonIterator;
        JSONObject jsonObject;
        FileOperation fileOperation = new FileOperation();
        
        try {
            // Reads the content of the json file.
            String jsonString = fileOperation.getTextContent(jsonFile);
            jsonObject = new JSONObject(jsonString);
            jsonIterator = jsonObject.keys();
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            return downloadedDataList;
        }
        
        String rootKeyString, subjectString, titleString;
        String yearString = "";
        identifierVariableName += ":";   
        
        while (jsonIterator.hasNext()) {
            rootKeyString = (String)jsonIterator.next();
            
            try {
                // Reads the subject url.
                subjectString = jsonObject.getJSONObject(
                        rootKeyString).getString("url");
                // Reads the title.
                titleString = jsonObject.getJSONObject(
                        rootKeyString).getString("title");
            }
            catch (Exception ex) {
                // If a subject or a title not found.
                continue;
            }
            
            try {
                // Reads the publication year.
                yearString = jsonObject.getJSONObject(
                        rootKeyString).getString("publish_date");
            }
            catch (Exception ex) {
            }
            // A title is necessary for the data to be added.
            if (titleString.length() > 0) {
                // The identifier to be added.
                rootKeyString =
                        rootKeyString.replace(identifierVariableName, "");
                downloadedDataList.add(new ExtractedData(subjectString,
                        rootKeyString, titleString, yearString));
            }
        }
        
        return downloadedDataList;
    }
    
    /**
     * Downloads data via the PubMed API. For the rules and limitations (the
     * maximum number of identifiers in a single query, delay between
     * consecutive queries etc.) please consult the API's documentation 
     *  <a href="https://www.ncbi.nlm.nih.gov/books/NBK25497/">
     *  https://www.ncbi.nlm.nih.gov/books/NBK25497/</a><br>
     * The API must be used only after conformity with the specified rules.
     * @param identifierSet A set of identifiers to be queried.
     * @param identifierType The type of the queried identifier.
     * @param destRepositoryConn Connection to the destination repository where
     * the downloaded data will be saved.
     * @param schema Provides structure for the saved data.
     * @return The number of downloaded records.
     */
    public int downloadPubMedData(Set<String> identifierSet,
            IdentifierType identifierType,
            RepositoryConnection destRepositoryConn, Schema schema) {
        int downloadCount = 0;
        // The API can only be used to query PubMed IDs (PMIDs). For information
        // about the ID structure check the following link
        // https://en.wikipedia.org/wiki/PubMed#PubMed_identifier
        if (identifierType != IdentifierType.PMID)
            return downloadCount;
        // Checks for missing authentication parameters.
        if (pubmedAuthenticationMissing(pubmedDLParameterData))
            return downloadCount;
        // Download parameters.
        int connectTimeout = pubmedDLParameterData.getConnectTimeout();
        int readTimeout = pubmedDLParameterData.getReadTimeout();
        int insertBatchSize = pubmedDLParameterData.getInsertBatchSize();
        int downloadBatchSize = pubmedDLParameterData.getDownloadBatchSize();
        int downloadDelay = pubmedDLParameterData.getDownloadDelay();
        int maxAllowedConsecutiveErrors =
                pubmedDLParameterData.getMaxAllowedConsecutiveErrors();
        // Authentication parameters.
        String apiTool = pubmedDLParameterData.getAPITool();
        String apiEmail = pubmedDLParameterData.getAPIEmail();
        
        int logCount = 0;
        FileOperation fileOperation = new FileOperation();
        Identifier identifier = new Identifier();
        // An identifier name for logging.
        String identifierName = identifier.getIdentifierName(identifierType);
        // An identifier name for variables.
        String identifierVariableName =
                identifier.getIdentifierVariableName(identifierType);
        URL apiURL;
        Path downloadPath;
        
        logger.logMessage("Downloading " + identifierName + 
                " data from PubMed...", MessageCategory.Info);
        
        try {
            apiURL = new URL("https://eutils.ncbi.nlm.nih.gov/entrez/eutils/");
            // Creates a temporary download folder.
            downloadPath = Files.createTempDirectory("biblc_pubmed_" +
                    identifierVariableName + "_");
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            return downloadCount;
        }
        
        String queryString = "esummary.fcgi?db=pubmed&tool=" + apiTool + 
                             "&email=" + apiEmail + "&id=";
        // The base URL that will be used to create the subjects. A subject URI
        // will be generated after concatenating the base URL with a PMID.
        String pubmedURLString = "https://www.ncbi.nlm.nih.gov/pubmed/";
        URL fileURL;
        File file;
        String filename;
        List<ExtractedData> collectiveList = new ArrayList<>();
        // A list that contains delimited identifier chains and a count for the
        // identifiers present in each chain.
        List<IdentifierChainData> identifierChainDataList =
                getIdentifierChainDataList(identifierSet, "", "", ",",
                        downloadBatchSize);
        int consecutiveErrors = 0;
        int queryCount = 0;
        IdentifierChainData identifierChainData;
        String identifierChain ;
        int identifierCount;
        long startTime;
        
        for (int i = 0; i < identifierChainDataList.size(); i++) {
            if (consecutiveErrorsExceedMaxAllowed(consecutiveErrors,
                    maxAllowedConsecutiveErrors))
                return downloadCount;
            // Begins the timing of the duration between consecutive queries.
            startTime = System.currentTimeMillis();
            // The name of the temporary file where the downloaded content will
            // be saved.
            filename = "batch_" + (i + 1) + ".xml";
            identifierChainData = identifierChainDataList.get(i);
            // The delimited identifier chain.
            identifierChain = identifierChainData.getIdentifierChain();
            // The number of identifiers in the chain.
            identifierCount = identifierChainData.getIdentifierCount();
            
            try {
                // The URL that will be used to download the data.
                fileURL = new URL(apiURL, queryString + identifierChain);
            }
            catch (Exception ex) {
                logger.logMessage(ex.getMessage(), MessageCategory.Error);
                consecutiveErrors++;
                continue;
            }
            // A file where the downloaded data will be saved.
            file = new File(downloadPath.toString(), filename);
            
            try {
                queryCount += identifierCount;
                // Data download.
                FileUtils.copyURLToFile(fileURL, file, connectTimeout,
                        readTimeout);
                // The variable is initialized after a successful download.
                consecutiveErrors = 0;
            }
            catch (Exception ex) {
                logger.logMessage(ex.getMessage(), MessageCategory.Error);
                consecutiveErrors++;
                continue;
            }
            // Reads the downloaded file's content.
            List<ExtractedData> extractedDataList = getPubMedData(file);
            collectiveList.addAll(extractedDataList);
            downloadCount += extractedDataList.size();
            fileOperation.deleteTempFile(file);
            // The collected content will be sent to the repository as a batch.
            if (collectiveList.size() >= insertBatchSize) {
                if (executeTransaction(collectiveList, pubmedURLString,
                        identifierVariableName, destRepositoryConn,
                        schema) == false)
                    return downloadCount;
                
                collectiveList.clear();
            }
            // A message will be logged based on the downloadMessageRecords
            // value.
            logCount = logDownloadMessage(logCount, queryCount, downloadCount,
                    identifierName);
            // Delay between consecutive downloads.
            delayDownload(startTime, downloadDelay);
        }
        // The remaining content will be sent to the repository.
        if (collectiveList.size() > 0) {
            if (executeTransaction(collectiveList, pubmedURLString, 
                    identifierVariableName, destRepositoryConn,
                    schema) == false)
                return downloadCount;
            
            collectiveList.clear();
        }
        // Deletes the temporary download folder.
        fileOperation.deleteTempFolder(downloadPath);
        logger.logMessage("\ttotal records downloaded and saved : " +
                String.valueOf(downloadCount), MessageCategory.Info);
        
        return downloadCount;
    }
    
    /**
     * Extracts the content of a file downloaded via the PubMed API.
     * @param xmlFile The downloaded xml file.
     * @return An extracted data list.
     */
    private List<ExtractedData> getPubMedData(File xmlFile) {
        List<ExtractedData> downloadedDataList = new ArrayList<>();
        NodeList docSumNodeList;
        
        try {
            DocumentBuilderFactory builderFactory =
                    DocumentBuilderFactory.newInstance();
            // Prevents the default validation of the file's structure.
            builderFactory.setFeature("http://apache.org/xml/features/" + 
                    "nonvalidating/load-external-dtd", false);
            DocumentBuilder builder = builderFactory.newDocumentBuilder();
            // Reads the file.
            Document xmlDocument = builder.parse(xmlFile);
            XPath xPath =  XPathFactory.newInstance().newXPath();
            // XPath expression to retrieve an element.
            String expression = "/eSummaryResult/DocSum";
            docSumNodeList = (NodeList) xPath.evaluate(expression,
                    xmlDocument, XPathConstants.NODESET);
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Warning);
            return downloadedDataList;
        }
        
        String pmid;
        String title = "";
        String year = "";
        String nameValue;
        // Iteration through all the results retrieved.
        for (int i = 0; i < docSumNodeList.getLength(); i++) {
            try {
                Node docSumNode = docSumNodeList.item(i);
                
                if (docSumNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element docSumElement = (Element) docSumNode;
                    // Reads the identifier.
                    pmid = docSumElement.getElementsByTagName("Id").
                            item(0).getTextContent();
                    NodeList docSumChildNodeList =
                            docSumElement.getElementsByTagName("Item");
                    
                    for (int j = 0; j < docSumChildNodeList.getLength(); j++) {                       
                        Element docSumChildElement =
                                (Element) docSumChildNodeList.item(j);
                        nameValue = docSumChildElement.getAttribute("Name");
                        
                        switch (nameValue) {
                            case "Title":
                                // Reads the title.
                                title = docSumChildElement.getTextContent();
                                break;
                            case "PubDate":
                                year = docSumChildElement.getTextContent();
                                // Separates the publication year.
                                year = year.substring(0, 4);
                                break;
                        }
                        
                        if (title.length() > 0 && year.length() > 0)
                            break;
                    }
                    // The ID and the title are the minimum necessary data.
                    if (pmid.length() > 0 && title.length() > 0)
                        downloadedDataList.add(new ExtractedData(
                                "", pmid, title, year));
                    
                    title = "";
                    year = "";
                }
            }
            catch (Exception ex) {
            }
        }
        
        return downloadedDataList;
    }
    
    /**
     * Checks for missing PubMed API authentication parameters.
     * @param pubmedDLParameterData The downloaded parameters to be used.
     * @return The authentication parameters adequacy.
     */
    private boolean pubmedAuthenticationMissing(
            PubMedDownloadParameterData pubmedDLParameterData) {
        boolean authenticationMissing = false;
        // The registration email is mandatory.
        if (pubmedDLParameterData.getAPIEmail().length() == 0) {
            logger.logMessage("email not provided for PubMed " +
                    "authentication", MessageCategory.Warning);
            authenticationMissing = true;
        }
        // The tool name is mandatory.
        if (pubmedDLParameterData.getAPITool().length() == 0) {
            logger.logMessage("tool not provided for PubMed " + 
                    "authentication", MessageCategory.Warning);
            authenticationMissing = true;
        }
        
        return authenticationMissing;
    }
    
    /**
     * Downloads data via the WorldCat API. For the rules and limitations (the
     * maximum number of identifiers in a single query, delay between
     * consecutive queries etc.) please consult the API's documentation 
     *  <a href="https://www.oclc.org/developer/develop/data-sets.en.html">
     *  https://www.oclc.org/developer/develop/data-sets.en.html</a><br>
     * The API must be used only after conformity with the specified rules.
     * @param identifierSet A set of identifiers to be queried.
     * @param identifierType The type of the queried identifier.
     * @param destRepositoryConn Connection to the destination repository where
     * the downloaded data will be saved.
     * @param schema Provides structure for the saved data.
     * @return The number of downloaded records.
     */
    private int downloadWorldCatData(Set<String> identifierSet,
            IdentifierType identifierType,
            RepositoryConnection destRepositoryConn) {
        int downloadCount = 0;
        // The API can only be used to query WorldCat OCLC identifiers. For
        // information about the OCLC structure check the following link
        // https://www.oclc.org/batchload/controlnumber.en.html
        if (identifierType != IdentifierType.OCLC)
            return downloadCount;
        // Download parameters.
        int connectTimeout = worldcatDLParameterData.getConnectTimeout();
        int readTimeout = worldcatDLParameterData.getReadTimeout();
        int insertBatchSize = worldcatDLParameterData.getInsertBatchSize();
        int downloadBatchSize = worldcatDLParameterData.getDownloadBatchSize();
        int downloadDelay = worldcatDLParameterData.getDownloadDelay();
        int maxAllowedConsecutiveErrors =
                worldcatDLParameterData.getMaxAllowedConsecutiveErrors();
        int attemptCount = worldcatDLParameterData.getAttemptCount();
        int delayBetweenAttemps =
                worldcatDLParameterData.getDelayBetweenAttemps();
        int logCount = 0;
        
        FileOperation fileOperation = new FileOperation();
        Identifier identifier = new Identifier();
        // An identifier name for logging.
        String identifierName = identifier.getIdentifierName(identifierType);
        // An identifier name for variables.
        String identifierVariableName =
                identifier.getIdentifierVariableName(identifierType);
        URL apiURL;
        Path downloadPath;
        
        logger.logMessage("Downloading " + identifierName + 
                " data from WorldCat...", MessageCategory.Info);
        
        try {
            apiURL = new URL("http://www.worldcat.org/oclc/");
            // Creates a temporary download folder.
            downloadPath = Files.createTempDirectory("biblc_worldcat_" +
                    identifierVariableName + "_");
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            return downloadCount;
        }
        
        URL fileURL;
        ExecutorService executorService =
                Executors.newFixedThreadPool(downloadBatchSize);
        Callable callable;
        List<Future> callResultList = new ArrayList<>();
        File file;
        String filename;
        List<File> fileList = new ArrayList();
        List<File> collectiveList = new ArrayList();
        // A list that contains delimited identifier chains and a count for the
        // identifiers present in each chain.
        List<IdentifierChainData> identifierChainDataList =
                getIdentifierChainDataList(identifierSet, "", "", ",",
                        downloadBatchSize);
        int consecutiveErrors = 0;
        int consecutiveDownloadErrors;
        int queryCount = 0;
        IdentifierChainData identifierChainData;
        String identifierChain;
        long startTime;
        
        for (int i = 0; i < identifierChainDataList.size(); i++) {
            // Begins the timing of the duration between consecutive queries.
            startTime = System.currentTimeMillis();
            
            identifierChainData = identifierChainDataList.get(i);
            // The delimited identifier chain.
            identifierChain = identifierChainData.getIdentifierChain();
            // Converts the identifier chain to an array.
            String[] identifierArray = identifierChain.split(",");
            
            for (String identifierString : identifierArray) {
                // The name of the temporary file where the downloaded content
                // will be saved.
                filename = identifierString + ".ttl";
                
                try {
                    // The URL that will be used to download the data.
                    fileURL = new URL(apiURL, filename);
                }
                catch (Exception ex) {
                    logger.logMessage(ex.getMessage(), MessageCategory.Error);
                    consecutiveErrors++;
                    continue;
                }
                // A file where the downloaded data will be saved.
                file = new File(downloadPath.toString(), filename);
                fileList.add(file);
                // A callable which will be used to download the file.
                callable = new WorldCatCallable(fileURL, file, connectTimeout,
                        readTimeout, attemptCount, delayBetweenAttemps);
                // Initiates a download via a new thread.
                callResultList.add(executorService.submit(callable));
                queryCount++;
            }
            
            try {
                executorService.shutdown();
                // Waits for termination of all the download threads.
                executorService.awaitTermination(Long.MAX_VALUE,
                        TimeUnit.SECONDS);
            }
            catch (Exception ex) {
                logger.logMessage(ex.getMessage(), MessageCategory.Error);
                consecutiveErrors++;
                continue;
            }
            
            collectiveList.addAll(fileList);
            // Adds the count of the successfully downloaded files.
            downloadCount += getFileCount(fileList);
            fileList.clear();
            // The collected content will be sent to the repository as a batch.
            if (getFileCount(collectiveList) >= insertBatchSize) {
                if (executeTransaction(collectiveList,
                        destRepositoryConn) == false)
                    return downloadCount;
                
                collectiveList.clear();
            }
            // Creates a new thread pool based on the provided batch size.
            executorService = Executors.newFixedThreadPool(downloadBatchSize);
            // Retrieves the number of consecutive errors.
            consecutiveDownloadErrors =
                    getConsecutiveErrorCount(callResultList);
            
            if (consecutiveDownloadErrors == 0)
                consecutiveErrors = 0;
            else
                consecutiveErrors += consecutiveDownloadErrors;
            
            if (consecutiveErrorsExceedMaxAllowed(consecutiveErrors,
                    maxAllowedConsecutiveErrors))
                return downloadCount;
            
            // A message will be logged based on the downloadMessageRecords
            // value.
            logCount = logDownloadMessage(logCount, queryCount, downloadCount,
                    identifierName);
            // Delay between consecutive downloads.
            delayDownload(startTime, downloadDelay);
        }
        // The remaining content will be sent to the repository.
        if (getFileCount(collectiveList) > 0) {
            if (executeTransaction(collectiveList, destRepositoryConn) == false)
                return downloadCount;
            
            collectiveList.clear();
        }
        // Deletes the temporary download folder.
        fileOperation.deleteTempFolder(downloadPath);
        logger.logMessage("\ttotal records downloaded and saved : " +
                String.valueOf(downloadCount), MessageCategory.Info);
        
        return downloadCount;
    }
    
    /**
     * Gets the count of the successfully downloaded files.
     * @param fileList A list of files.
     * @return The count of the successful downloads.
     */
    private int getFileCount(List<File> fileList) {
        int fileCount = 0;
        File file;
        
        for (int i = 0; i < fileList.size(); i++) {
            file = fileList.get(i);
            
            if (file.exists())
                fileCount++;
        }
        
        return fileCount;    
    }
    
    /**
     * Sends the ttl (turtle) file batch into the destination repository .
     * @param fileList A list of ttl files.
     * @param destRepositoryConn A connection to the destination repository
     * where the files will be sent.
     * @return The success of sending the batch.
     */
    private boolean executeTransaction(List<File> fileList,
            RepositoryConnection destRepositoryConn) {
        boolean result = true;
        
        try {
            File file;
            FileOperation fileOperation = new FileOperation();
            // Begins a transation.
            destRepositoryConn.begin();
            
            for (int i = 0; i < fileList.size(); i++) {
                file = fileList.get(i);
                
                if (file.exists()) {
                    // Sends the ttl file into the repository.
                    destRepositoryConn.add(file, null, RDFFormat.TURTLE);
                    // Deletes the temporary file after success.
                    fileOperation.deleteTempFile(file);
                }
            }
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            result = false;
        }
        finally {
            try {
                // Commits the transation.
                destRepositoryConn.commit();
            }
            catch (Exception ex) {
            }
        }
        
        return result;
    }
    
    /**
     * Gets a SPARQL query which can be used to retrieve data downloaded via the
     * WorldCat API.
     * @param identifierType The type of the identifier.
     * @return The data selection SPARQL query.
     */
    public String getWorldCatDataSelectionQuery(IdentifierType identifierType) {
        if (identifierType != IdentifierType.OCLC)
            return "";
        
        String worldcatOCLCQuery = 
            "PREFIX library: <http://purl.org/library/>               \n" +
            "PREFIX schema: <http://schema.org/>                      \n" +
            "                                                         \n" +
            "SELECT                                                   \n" +
            "    *                                                    \n" +
            "WHERE                                                    \n" +
            "    {                                                    \n" +
            "        ?subject library:oclcnum ?oclc .                 \n" +
            "        ?subject schema:name ?title .                    \n" +
            "        OPTIONAL {?subject schema:datePublished ?year .} \n" +
            "    }                                                    \n";
        
        return worldcatOCLCQuery;
    }
    
    /**
     * Gets a SPARQL query which can be used to retrieve data downloaded via the
     * arXiv, HathiTrust, Open Library and PubMed API.
     * @param identifierType The type of the identifier.
     * @param schema The structure information of the saved data.
     * @return The data selection SPARQL query.
     */
    public String getDownloadedDataSelectionQuery(IdentifierType identifierType,
            Schema schema) {
        String dataSelectionQuery;
        Identifier identifier = new Identifier();
        String identifierVariableName =
                identifier.getIdentifierVariableName(identifierType);
        dataSelectionQuery = 
            "PREFIX prop: <" + schema.getPropertyPath() + ">           \n" +
            "                                                          \n" +
            "SELECT                                                    \n" +
            "    *                                                     \n" +
            "WHERE                                                     \n" +
            "    {                                                     \n" +
            "        ?subject prop:" + identifierVariableName + " ?" +
                     identifierVariableName + " .                      \n" +
            "        ?subject prop:title ?title .                      \n" +
            "        OPTIONAL {?subject prop:year ?year .}             \n" +
            "    }                                                     \n";
        
        return dataSelectionQuery;
    }
    
    /**
     * Checks for the validity of the selected API and identifier combination.
     * @param sourceType The download API source.
     * @param identifierType The type of the queried identifier.
     * @return The validity of the combination.
     */
    private boolean isSourceIdentifierCombinationValid(SourceType sourceType,
            IdentifierType identifierType) {
        boolean isValid = true;
        String messagePart = "The identifier " + identifierType.name() +
                " is not supported for " + sourceType.name() + ". ";
        
        switch (sourceType) {
            case arXiv:
                if (identifierType != IdentifierType.arXivID) {
                    logger.logMessage(messagePart + "Valid value: arXivID",
                            MessageCategory.Warning);
                    isValid = false;
                }
                break;
            case HathiTrust: case OpenLibrary:
                if (identifierType != IdentifierType.ISBN &&
                    identifierType != IdentifierType.LCCN &&
                    identifierType != IdentifierType.OCLC) {
                    logger.logMessage(messagePart +
                            "Valid values: ISBN, LCCN, OCLC",
                            MessageCategory.Warning);
                    isValid = false;
                }
                break;
            case PubMed:
                if (identifierType != IdentifierType.PMID) {
                    logger.logMessage(messagePart + "Valid value: PMID",
                            MessageCategory.Warning);
                    isValid = false;
                }
                break;
            case WorldCat:
                if (identifierType != IdentifierType.OCLC) {
                    logger.logMessage(messagePart + "Valid value: OCLC",
                            MessageCategory.Warning);
                    isValid = false;
                }
                break;
        }
        
        return isValid;
    }
    
    /**
     * Logs the missing necessary source repository parameters.
     * @param sourceRepositoryInfo Information about the source repository that
     * will provide the identifiers that will be queried for data downloading.
     * @return A value indicating if a parameter is missing.
     */
    private boolean sourceRepositoryParameterMissing(
            RepositoryInfo sourceRepositoryInfo) {
        boolean parameterMissing = false;
        
        if (sourceRepositoryInfo == null) {
            this.logger.logMessage("sourceRepositoryInfo is null",
                    MessageCategory.Warning);
            parameterMissing = true;
            return parameterMissing;
        }
        
        if (sourceRepositoryInfo.getRepositoryID().length() == 0) {
            this.logger.logMessage("sourceRepositoryInfo repositoryID not set",
                    MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (sourceRepositoryInfo.getRepositoryName().length() == 0) {
            this.logger.logMessage("sourceRepositoryInfo repositoryName not " +
                    "set", MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (sourceRepositoryInfo.getServerURLString().length() == 0) {
            this.logger.logMessage("sourceRepositoryInfo serverURLString not " +
                    "set", MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (sourceRepositoryInfo.getAuthenticationData() != null) {
            AuthenticationData authenticationData =
                    sourceRepositoryInfo.getAuthenticationData();
            
            if (authenticationData.getUsername().length() == 0) {
                this.logger.logMessage("sourceRepositoryInfo " +
                        "authenticationData username not set",
                        MessageCategory.Warning);
                parameterMissing = true;
            }
            
            if (authenticationData.getPassword().length() == 0) {
                this.logger.logMessage("sourceRepositoryInfo " +
                        "authenticationData password not set",
                        MessageCategory.Warning);
                parameterMissing = true;
            }
        }
        
        return parameterMissing;
    }
    
    /**
     * Logs the missing necessary destination repository parameters.
     * @return A value indicating if a parameter is missing.
     */
    private boolean destRepositoryParameterMissing(
            RepositoryInfo destRepositoryInfo) {
        boolean parameterMissing = false;
        
        if (destRepositoryInfo == null) {
            this.logger.logMessage("destRepositoryInfo is null",
                    MessageCategory.Warning);
            parameterMissing = true;
            return parameterMissing;
        }
        
        if (destRepositoryInfo.getRepositoryID().length() == 0) {
            this.logger.logMessage("destRepositoryInfo repositoryID not set",
                    MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (destRepositoryInfo.getServerURLString().length() == 0) {
            this.logger.logMessage("destRepositoryInfo serverURLString not set",
                    MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (destRepositoryInfo.getSchemaURLString().length() == 0) {
            this.logger.logMessage("destRepositoryInfo schemaURLString not set",
                    MessageCategory.Warning);
            parameterMissing = true;
        }
        
        if (destRepositoryInfo.getAuthenticationData() != null) {
            AuthenticationData authenticationData =
                    destRepositoryInfo.getAuthenticationData();
            
            if (authenticationData.getUsername().length() == 0) {
                this.logger.logMessage("destRepositoryInfo " + 
                        "authenticationData username not set",
                        MessageCategory.Warning);
                parameterMissing = true;
            }
            
            if (authenticationData.getPassword().length() == 0) {
                this.logger.logMessage("destRepositoryInfo " +
                        "authenticationData password not set",
                        MessageCategory.Warning);
                parameterMissing = true;
            }
        }
        
        return parameterMissing;
    }

    /**
     * Checks if the maximum number of consecutive errors during the download
     * has been exceeded.
     * @param consecutiveErrors The number of consecutive errors.
     * @param maxAllowedConsecutiveErrors The maximum allowed number of
     * consecutive errors.
     * @return A value indicating if the maximum number of consecutive errors
     * has been exceeded.
     */
    private boolean consecutiveErrorsExceedMaxAllowed(int consecutiveErrors,
            int maxAllowedConsecutiveErrors) {
        boolean errorsExceed = false;
        
        if (consecutiveErrors >= maxAllowedConsecutiveErrors) {
            logger.logMessage("the maximum number of consecutive " +
                    "errors allowed during download has been exceeded",
                    MessageCategory.Warning);
            errorsExceed = true;
        }
        
        return errorsExceed;
    }
    
    /**
     * Gets the count of the consecutive errors.
     * @param callResultList A future list containing the errors generated 
     * during each thread.
     * @return The consecutive error count.
     */
    private int getConsecutiveErrorCount(List<Future> callResultList) {
        int consecutiveErrorCount = 0;
        int errorCount;
        Future callResult;
        
        for (int i = 0; i < callResultList.size(); i++) {
            try {
                callResult = callResultList.get(i);
                errorCount = (int) callResult.get();
                
                if (errorCount == 0)
                    // The variable is initialized after a successful download.
                    consecutiveErrorCount = 0;
                else
                    consecutiveErrorCount += errorCount;
            }
            catch (Exception ex) {
                consecutiveErrorCount++;
            }
        }
        
        return consecutiveErrorCount;
    }
    
    /**
     * Logs a message during the downloads depending on the value of the
     * downloadMessageRecords variable.
     * @param logCount The number of times a message has been logged.
     * @param downloadCount The number of records that have been downloaded.
     * @param identifierName The name of the identifier to be logged.
     * @return The number of times a message has been logged.
     */
    private int logDownloadMessage(int logCount, int queryCount,
            int downloadCount, String identifierName) {
        if (logCount != queryCount / downloadMessageRecords) {
            logCount = queryCount / downloadMessageRecords;
            // A suffix for the word "record".
            String recordSuffixA = (queryCount == 1) ? "" : "s";
            // A suffix for the word "record".
            String recordSuffixB = (downloadCount == 1) ? "" : "s";
            logger.logMessage("\tqueried " + String.valueOf(queryCount) + " " +
                    identifierName + " record" + recordSuffixA +
                    ", downloaded " + String.valueOf(downloadCount) +
                    " record" + recordSuffixB, MessageCategory.Info);
        }
        
        return logCount;
    }
    
    /**
     * Gets a list that contains delimited identifier chains and a count for the
     * identifiers present in each chain.
     * @param identifierSet The set of identifiers which will be used for the 
     * identifier chain creation.
     * @param identifierPrefix A prefix before each identifier of the chain.
     * @param identifierSuffix A suffix after each identifier of the chain.
     * @param delimiter The delimiter for separating the identifiers.
     * @param chainSize The number of identifiers in each chain.
     * @return A list of delimited identifier chain data.
     */
    private List<IdentifierChainData> getIdentifierChainDataList(
            Set<String> identifierSet, String identifierPrefix,
            String identifierSuffix, String delimiter, int chainSize) {
        List<IdentifierChainData> identifierChainList = new ArrayList<>();
        
        try {
            Iterator identifierSetIterator = identifierSet.iterator();
            String identifierString;
            String identifierChain = "";
            int identifierCounter = 0;
            
            while (identifierSetIterator.hasNext()) {
                identifierString = (String) identifierSetIterator.next();
                // The identifier chain creation.
                identifierChain += identifierPrefix + identifierString +
                        identifierSuffix + delimiter;
                // Counts the number of identifiers in a chain.
                identifierCounter++;
                // Determines if the chain is complete and can be added to the
                // list.
                if (identifierCounter >= chainSize) {
                    // Removes the last delimiter.
                    identifierChain = identifierChain.substring(0,
                            identifierChain.length() - delimiter.length());
                    IdentifierChainData identifierChainData =
                            new IdentifierChainData(identifierChain,
                                    identifierCounter);
                    // Adds the chain to the list.
                    identifierChainList.add(identifierChainData);
                    identifierChain = "";
                    identifierCounter = 0;
                }
            }
            // The remaining chain will be added to the list.
            if (identifierCounter > 0) {
                identifierChain = identifierChain.substring(0,
                        identifierChain.length() - delimiter.length());
                IdentifierChainData identifierChainData = new
                        IdentifierChainData(identifierChain, identifierCounter);
                identifierChainList.add(identifierChainData);
            }
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
        }
        
        return identifierChainList;
    }
    
    /**
     * Sends the extracted data batch into the destination repository.
     * @param extractedDataList A list containing the extracted data batch.
     * @param subjectBaseString The base URL that will be used to create the
     * subjects in case that they don't exist in the exractedDataList.
     * @param identifierVariableName The variable name for the identifier.
     * @param destRepositoryConn A connection to the destination repository
     * where the extracted data will be sent.
     * @param schema Provides structure for the saved data.
     * @return The success of sending the batch.
     */
    private boolean executeTransaction(List<ExtractedData> extractedDataList,
            String subjectBaseString, String identifierVariableName,
            RepositoryConnection destRepositoryConn, Schema schema) {
        boolean result = true;
        
        try {
            String subjectString, identifierString, titleString, yearString;
            URI subject, predicate;
            Literal object;
            ValueFactory valueFactory = destRepositoryConn.getValueFactory();
            // Begins a transation.
            destRepositoryConn.begin();
            
            for (int i = 0; i < extractedDataList.size(); i++) {                
                identifierString = extractedDataList.get(i).getIdentifier();
                // Checks if a subject exists in the list.
                if (extractedDataList.get(i).getSubject().length() > 0)
                    subjectString = extractedDataList.get(i).getSubject();
                else
                    // Creates the subject URL.
                    subjectString = subjectBaseString + identifierString;
                
                titleString = extractedDataList.get(i).getTitle();
                yearString = extractedDataList.get(i).getYear();
                
                subject = valueFactory.createURI(subjectString);
                predicate = valueFactory.createURI(schema.getPropertyPath() +
                        identifierVariableName);
                object = valueFactory.createLiteral(identifierString,
                        XMLSchema.STRING);
                // Adds the triple for the identifier.
                destRepositoryConn.add(subject, predicate, object);
                
                predicate = valueFactory.createURI(schema.getPropertyPath() +
                        "title");
                object = valueFactory.createLiteral(titleString,
                        XMLSchema.STRING);
                // Adds the triple for the title.
                destRepositoryConn.add(subject, predicate, object);
                
                if (yearString.length() > 0) {
                    predicate = valueFactory.createURI(
                            schema.getPropertyPath() + "year");
                    object = valueFactory.createLiteral(yearString,
                            XMLSchema.STRING);
                    // Adds the triple for the publication year.
                    destRepositoryConn.add(subject, predicate, object);
                }
            }
        }
        catch (Exception ex) {
            logger.logMessage(ex.getMessage(), MessageCategory.Error);
            result = false;
        }
        finally {
            try {
                // Commits the transation.
                destRepositoryConn.commit();
            }
            catch (Exception ex) {
            }
        }
        
        return result;
    }

    /**
     * Delays the current thread based on the timing initiation moment.
     * @param startTime The timing start (in milliseconds).
     * @param delay The delay (in milliseconds).
     */
    private void delayDownload(long startTime, int delay) {
        // Gets the current time in milliseconds.
        long stopTime = System.currentTimeMillis();
        // Calculates the elapsed time.
        long elapsedTime = stopTime - startTime;
        
        if (elapsedTime < delay)
            try {
                // Delays the thread.
                Thread.sleep(delay - elapsedTime);
            }
            catch (Exception ex) {
            }
    }
}